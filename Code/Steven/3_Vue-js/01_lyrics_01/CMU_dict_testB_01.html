<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>

    <script>
        import _ from 'underscore';
        import fs from 'fs';
    </script>
</head>
<body>

</body>

<script>


    function parseCMU(str) {
        const pronunciations = [];
        _.each(str.split("\n"), line => {
            if (/^;/.test(line)) { return; }
            if (line.length == 0) { return; }
            const parts = line.split("  ");
            let word = parts[0];
            const phones = parts[1];
            word = word.replace(/\(\d\)$/, '').toLowerCase();
            pronunciations.push([word, phones]);
        });
        return pronunciations;
    }

    const pronunciations = parseCMU(
        fs.readFileSync(`${__dirname}/cmudict-0.7b`, {encoding: 'utf8'}));

    function syllableCount(phones) {
        return _.reduce(
            _.map(phones, i => (i.match(/[012]/g)||[]).length),
            (a, b) => a+b)
    }

    function phonesForWord(find) {
        const matches = [];
        _.each(pronunciations, item => {
            const word = item[0];
            const phones = item[1];
            if (word == find) {
                matches.push(phones);
            }
        });
        return matches;
    }

    function rhymingPart(phones) {
        let idx = 0;
        const phonesList = phones.split(" ");
        for (let i = phonesList.length-1; i >= 0; i--) {
            if (phonesList[i].slice(-1).match(/[12]$/)) {
                idx = i;
                break;
            }
        }
        return phonesList.slice(idx).join(' ');
    }

    /**
     * If you give this function a string, it turns it into a RegExp object with
     * added word boundary anchors at beginning and end. You can also pass a
     * RegExp object, but in that case you need to add the word boundary anchors
     * yourself!
     */

    function search(pattern) {
        const matches = [];
        if (pattern instanceof RegExp) {
            re = pattern;
        }
        else {
            var re = new RegExp(`\\b${pattern}\\b`);
        }
        _.each(pronunciations, item => {
            const word = item[0];
            const phones = item[1];
            if (phones.match(re)) {
                matches.push(word);
            }
        });
        return matches;
    }

    function searchStresses(pattern) {
        const matches = [];
        const re = new RegExp(`\\b${pattern}\\b`);
        _.each(pronunciations, item => {
            const word = item[0];
            const phones = item[1];
            if (stresses(phones).match(re)) {
            }
        });
        return matches;
    }
                matches.push(word);

    function rhymes(word) {
        const allRhymes = [];
        const allPhones = phonesForWord(word);
        _.each(allPhones, phonesStr => {
            const part = rhymingPart(phonesStr);
            const rhymes = search(`${part}$`);
            allRhymes.push(...rhymes);
        });
        return _.filter(allRhymes, r => r != word);
    }

    function stresses(s) {
        return s.replace(/[^012]/g, "");
    }


    export default {
        parseCMU,
        syllableCount,
        phonesForWord,
        rhymingPart,
        search,
        rhymes,
        stresses,
        searchStresses
    };


</script>
</html>