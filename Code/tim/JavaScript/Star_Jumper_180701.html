</html><!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Star Jumper</title>
    <script type="text/javascript" src="color_parser.js"></script>
    <link href="https://fonts.googleapis.com/css?family=Open+Sans" rel="stylesheet">
    <style>
        body {
            color: white;
            background-color: black;
            font-family: 'Open Sans', sans-serif;
        }
        #world_cnv {
            /*background-image: url('whale_sulzenauer_big.jpg');*/
        }
        canvas {
            border: 1px solid white;
            background-size: 2400px 480px;
            position: absolute;
            top: 30px;
            left: 30px;

        }
        button {
            position: absolute;
            top: 520px;
            border-radius: 4px;
            z-index: 10;
        }
        #modal_background {
            display: none; /* Hidden by default */
            position: fixed; /* Stay in place */
            z-index: 11; /* Sit on top */
            left: 0;
            top: 0;
            width: 100%; /* Full width */
            height: 100%; /* Full height */
            overflow: auto; /* Enable scroll if needed */
            background-color: rgba(0,0,0,0.4); /* Black w/ opacity */
        }
        #instruction_modal_div {
            position: fixed;
            z-index: 12;
            margin-left: -40%;
            transition: margin-left 1s;
            height: 300px;
            width: 500px;
            top: 50px;
            border: 3px solid deepskyblue;
            background-color: white;
            border-radius: 4px;
            overflow: hidden;
        }
        #instruction_options_div {
            display: flex;
            text-align: center;
        }
        .option {
            flex: 1;
            margin: 5px;
            border-radius: 4px;
            border: 3px solid black;
            background-color: deepskyblue;
            font-size: 2em;
            font-weight: bolder;
            color: black;
        }
        #rules_option {
            background-color: darkorchid;
        }
        .option:hover {
            background: mediumblue !important;
            cursor: pointer;
        }
        .instruction_border {
            position: absolute;
            transition: margin-left 1s;
            width: 500px;
        }
        .instruction {
            height: 220px;
            margin: 5px;
            margin-top: 0;
            padding: 5px;
            border-radius: 4px;
            border: 3px solid black;
            color: black;
        }
        #instruction_div {
            display: flex;
        }
        #rules_border {
            margin-left: 0%;
        }
        #controls_border {
            margin-left: 100%;
        }
        #other_border {
            margin-left: 200%;
        }
        #instruction_div > button {
            position: absolute;
            left: 450px;
            top: 268px;
        }
    </style>
</head>
<body>
    <canvas id="world_cnv" width="1200" height="500"></canvas>
    <canvas id="sword_cnv" width="1200" height="500"></canvas>
    <!--<canvas id="player_shots_cnv" width="1200" height="500"></canvas>-->
    <!--<canvas id="enemy_attack_cnv" width="1200" height="500"></canvas>-->
    <div id="modal_background"></div>
    <div id="instruction_modal_div">
        <div id="instruction_options_div">
            <div id="rules_option" class="option">Rules</div>
            <div id="controls_option" class="option">Controls</div>
            <div id="other_option" class="option">Other</div>
        </div>
        <div id="instruction_div">
            <div id="rules_border" class="instruction_border">
                <div id="rules_div" class="instruction">
                    The object of Star Jumper is (to be determined)...
                </div>
            </div>
            <div id="controls_border" class="instruction_border">
                <div id="controls_div" class="instruction">
                    "A" / LEFT : go left<br>
                    "D" / RIGHT : go right<br>
                    "W" / UP : jump<br>
                    "S" / SPACE : pick up & place star<br>
                    LEFT CLICK : shoot star<br>
                    RIGHT CLICK (ABOVE) : flip up attack<br>
                    RIGHT CLICK (BELOW) : flip down attack
                </div>
            </div>
            <div id="other_border" class="instruction_border">
                <div id="other_div" class="instruction">
                    Other Stuff
                </div>
            </div>
            <button id="hide_modal_bt">Exit</button>
        </div>
    </div><br>
    <button id="show_modal_bt">Rules</button>
    <script>
        let world_cnv = document.querySelector('#world_cnv')
        let sword_cnv = document.querySelector('#sword_cnv')
        // let player_shots_cnv = document.querySelector('#player_shots_cnv')
        // let enemy_attack_cnv = document.querySelector('#enemy_attack_cnv')
        let show_modal_bt = document.querySelector('#show_modal_bt')
        let modal_background = document.querySelector('#modal_background')
        let instruction_modal_div = document.querySelector('#instruction_modal_div')
        let hide_modal_bt = document.querySelector('#hide_modal_bt')
        let rules_option = document.querySelector('#rules_option')
        let controls_option = document.querySelector('#controls_option')
        let other_option = document.querySelector('#other_option')
        let rules_border = document.querySelector('#rules_border')
        let controls_border = document.querySelector('#controls_border')
        let other_border = document.querySelector('#other_border')

        show_modal_bt.onclick = () => {
            modal_background.style.display = 'block'
            instruction_modal_div.style.transition = 'margin-left 1s'
            instruction_modal_div.style.marginLeft = '20%'
            world.play = false
        }
        hide_modal_bt.onclick = () => {
            rules_border.style.marginLeft = '0%'
            controls_border.style.marginLeft = '100%'
            other_border.style.marginLeft = '200%'
            instruction_modal_div.style.transition = 'none'
            instruction_modal_div.style.marginLeft = '-50%'
            modal_background.style.display = 'none'
            world.play = true
            window.requestAnimationFrame(animation_loop)
        }
        rules_option.onclick = () => {
            rules_option.style.backgroundColor = 'darkorchid'
            rules_border.style.marginLeft = '0%'
            controls_option.style.backgroundColor = 'deepskyblue'
            controls_border.style.marginLeft = '100%'
            other_option.style.backgroundColor = 'deepskyblue'
            other_border.style.marginLeft = '200%'
        }
        controls_option.onclick = () => {
            rules_option.style.backgroundColor = 'deepskyblue'
            rules_border.style.marginLeft = '-100%'
            controls_option.style.backgroundColor = 'darkorchid'
            controls_border.style.marginLeft = '0%'
            other_option.style.backgroundColor = 'deepskyblue'
            other_border.style.marginLeft = '100%'
        }
        other_option.onclick = () => {
            rules_option.style.backgroundColor = 'deepskyblue'
            rules_border.style.marginLeft = '-200%'
            controls_option.style.backgroundColor = 'deepskyblue'
            controls_border.style.marginLeft = '-100%'
            other_option.style.backgroundColor = 'darkorchid'
            other_border.style.marginLeft = '0%'
        }
    </script>
    <script>
        class Image {
            constructor(path, x, y) {
                this.element = document.createElement('img')
                this.element.src = path
                this.x = x
                this.y = y
              }
              draw(world_ctx) {
                    world_ctx.drawImage(this.element, this.x, this.y)
              }
        }

        // KEY TRACKER STUFF ==============================================
        class KeyTracker {
            constructor() {
                this.keys = [];
            }
            keyDown(key) {
                this.keys.push(key);
            }
            keyUp(key) {
                this.keys = this.keys.filter(function(e) {
                    return e !== key;
                });
            }
            isKeyDown(key) {
                return this.keys.indexOf(key) > -1;
            }
        }

        let color_index = 0                                                              ///// CHEAT COUNTER TO CYCLE COLORS
        let key_tracker = new KeyTracker()

        document.addEventListener('keydown', (evt) => {
            key_tracker.keyDown(evt.key)
            if (evt.key === 'b') {                                                       /////  CHEAT - CYCLE COLOR
                world.player.color = world.colors[color_index % world.colors.length]
                world.player.shot_speed = color_data[world.player.color].shot_speed
                world.player.shot_cost = color_data[world.player.color].shot_cost
                world.player.mx = color_data[world.player.color].mx
                world.player.rgb = new RGBColor(world.player.color)
                color_index += 1
            }
            if (evt.key === 'g') {                                                       /////  CHEAT - GOD MODE
                world.player.mx = 3.5
                world.player.energy = 999
                world.player.star_count = 999
            }
        })

        document.addEventListener('keyup', (evt) => {
            key_tracker.keyUp(evt.key);
        })

        ///// WORLD STUFF /////

        function random(lower, upper) {
            return lower + Math.random()*(upper-lower)
        }

        function getShotVelocities(x_destination, y_destination, x_origin, y_origin, speed) {
            let dx = x_destination - x_origin
            let dy = y_destination - y_origin
            let return_vx = speed * dx / (Math.abs(dx) + Math.abs(dy))
            let return_vy = speed * dy / (Math.abs(dx) + Math.abs(dy))
            return {vx: return_vx, vy: return_vy}
        }

        function getClosestTarget(x, y, enemies) {
            let closest_enemy
            let smallest_separation2 = 999999
            for (let i=0; i<enemies.length; i++) {
                if (!enemies[i].dead) {
                    let change_in_x = x - enemies[i].x + enemies[i].width / 2
                    let change_in_y = y - enemies[i].y + enemies[i].height / 2
                    let separation2 = change_in_x * change_in_x + change_in_y * change_in_y
                    if (separation2 < smallest_separation2) {
                        smallest_separation2 = separation2
                        closest_enemy = enemies[i]
                    }
                }
            }
            return closest_enemy
        }

        class Rectangle {
            constructor(x, y, width, height, color) {
                this.x = x
                this.y = y
                this.width = width
                this.height = height
                this.color = color
                this.rgb = new RGBColor(color)
            }
            update() {
                this.x += this.vx
                this.y += this.vy
            }
            draw(ctx) {
                ctx.fillStyle = this.color
                ctx.fillRect(this.x, this.y, this.width, this.height)
            }
            left() {
                return this.x
            }
            right() {
                return this.x + this.width
            }
            top() {
                return this.y
            }
            bottom() {
                return this.y + this.height
            }
            cx() {
                return this.x + this.width / 2
            }
            cy() {
                return this.y + this.height / 2
            }
            checkCollideRec(rec) {
                let dx = (this.x + this.width/2) - (rec.x + rec.width/2)
                let dy = (this.y + this.height/2) - (rec.y + rec.height/2)
                let x_width = (this.width + rec.width) / 2
                let x_height = (this.height + rec.height) / 2
                return Math.abs(dx) <= x_width && Math.abs(dy) <= x_height
            }
        }

        class StarJumper extends Rectangle {
            constructor(x, y, width, height, color) {
                super(x, y, width, height, color);
                this.vy = 0
                this.vx = 0
                this.mx = color_data[color].mx
                this.star_count = 50
                this.star_cooldown = 0
                this.staa_ridin = false
                this.hurt_count = 0
                this.last_teleport = {}
                this.score = 0
                this.base_health = 100
                this.health = 100
                this.base_energy = 100
                this.energy = 100
                this.shots = []
                this.shot_trails = []
                this.sword_tip = {x:0, y:0}
                this.sword_trail = []
                this.flip_duration = 60
                this.flip_count = 0
                this.flip_rotation = ''
                this.flip_type = ''
                this.facing = 1 // right
            }
            draw(world_ctx, sword_ctx, ground_y) {
                let draw_me = true
                if (this.hurt_count > 60 && this.hurt_count % 3 != 0) {
                    draw_me = false
                } else if (this.hurt_count > 0 && this.hurt_count % 2 === 0) {
                    draw_me = false
                }
                if (draw_me) {
                    world_ctx.save();
                    let grd = world_ctx.createLinearGradient(0, 0, this.width * this.facing, -this.height / 4)
                    grd.addColorStop(0, this.color)
                    grd.addColorStop(1, "white")
                    world_ctx.fillStyle = grd
                    world_ctx.translate(this.x + this.width / 2, this.y + this.height / 2)
                    if (this.flip_count < 31) {
                        if (this.flip_rotation === 'clockwise') {
                            world_ctx.rotate(-Math.PI * this.flip_count / 15)
                        } else {
                            world_ctx.rotate(Math.PI * this.flip_count / 15)
                        }
                    }
                    world_ctx.fillRect(-this.width / 2, -this.height / 2, this.width, this.height)
                    world_ctx.restore()
                }
                ///// FLIPPING === SWORD SEQUENCE /////
                if (this.flip_count > 0) {
                    let cx = this.cx()
                    let cy = this.cy()
                    let adj_cy = 0
                    ///// FLIP SEQUENCE IS 60 FRAMES, SWORD STARTS AFTER FRAME 10 /////
                    if (this.flip_count < 50) {
                        ///// UP SEQUENCE - GET SWORD TIPS/////
                        if (this.flip_type === 'up') {
                            if (this.flip_count > 40) {
                                this.sword_tip.x = cx + (50 - this.flip_count) * 5 * this.facing // full length = 50
                                this.sword_tip.y = cy
                            } else if (this.flip_count > 10) {
                                let dx = Math.cos((41 - this.flip_count) / 40 * Math.PI) * 50
                                let dy = Math.sin((41 - this.flip_count) / 40 * Math.PI) * 50
                                this.sword_tip.x = cx + dx * this.facing
                                this.sword_tip.y = cy - dy
                            } else {
                                let dx = Math.cos((41 - this.flip_count) / 40 * Math.PI) * 5 * this.flip_count
                                let dy = Math.sin((41 - this.flip_count) / 40 * Math.PI) * 5 * this.flip_count
                                this.sword_tip.x = cx + dx * this.facing
                                this.sword_tip.y = cy - dy
                            }
                        ///// DOWN SEQUENCE - GET SWORD TIPS /////
                        } else {
                            this.sword_tip.x = cx
                            this.sword_tip.y = cy
                            if (this.flip_count > 40) {
                                let dx = Math.cos((this.flip_count - 40) * 0.075 * Math.PI) * 50
                                let dy = Math.sin((this.flip_count - 40) * 0.075 * Math.PI) * 50
                                this.sword_tip.x = cx + dx * this.facing
                                this.sword_tip.y = cy - dy
                            } else {
                                adj_cy = (40 - this.flip_count) / 2
                                this.sword_tip.x = cx + 50 * this.facing
                                this.sword_tip.y = cy + adj_cy
                            }
                        }
                        this.sword_trail[this.sword_trail.length - 1].push({
                            cx: cx,               tx: this.sword_tip.x,
                            cy: cy + adj_cy,      ty: this.sword_tip.y,      life: 100
                        })
                        world_ctx.strokeStyle = this.color
                        world_ctx.beginPath()
                        world_ctx.moveTo(cx, cy)
                        world_ctx.lineTo(this.sword_tip.x, this.sword_tip.y)
                        world_ctx.stroke()
                    }
                }
                if (this.sword_trail.length > 0) {
                    if (this.sword_trail[0].length === 0 && this.sword_trail.length>1) {
                        this.sword_trail.splice(0, 1)
                    }
                    // sword_ctx.fillStyle = this.color
                    for (let k=0; k<this.sword_trail.length; k++) {
                        let poly_path = {tip: [], cen: []}
                        for (let i = 0; i < this.sword_trail[k].length; i++) {
                            this.sword_trail[k][i].life -= 1
                            if (this.sword_trail[k][i].life === 0) {
                                this.sword_trail[k].splice(i, 1)
                                continue
                            }
                            poly_path.tip.push({x: this.sword_trail[k][i].tx, y: this.sword_trail[k][i].ty})
                            poly_path.cen.push({x: this.sword_trail[k][i].cx, y: this.sword_trail[k][i].cy})
                        }
                        if (poly_path.tip.length > 0) {
                            sword_ctx.strokeStyle = this.color
                            let alpha = this.sword_trail[k][this.sword_trail[k].length-1].life / 180 + 0.2
                            sword_ctx.fillStyle = "rgba(" + this.rgb["r"] + "," + this.rgb["g"] + "," + this.rgb["b"] +
                                "," + alpha + ")"
                            sword_ctx.beginPath()
                            sword_ctx.moveTo(poly_path.tip[0].x, poly_path.tip[0].y)
                            for (let i = 1; i < poly_path.tip.length; i++) {
                                if (this.flip_type === 'down'
                                    && poly_path.tip[i].y > ground_y - this.height
                                    && i === poly_path.tip.length - 1) {
                                    sword_ctx.lineTo(poly_path.tip[i].x, ground_y)
                                    // console.log(world.sword_ctx_data)
                                } else {
                                    sword_ctx.lineTo(poly_path.tip[i].x, poly_path.tip[i].y)
                                }
                            }
                            for (let i = poly_path.cen.length - 1; i > 0; i--) {
                                sword_ctx.lineTo(poly_path.cen[i].x, poly_path.cen[i].y)
                            }
                            sword_ctx.closePath()
                            sword_ctx.stroke()
                            sword_ctx.fill()
                        }
                    }
                }
            }
            withinVert(r) {
                return this.top() < r.bottom()
                    && this.bottom() > r.top()
            }
            rubRight(r) {
                return this.right() < r.left()
                    && this.right() + this.mx >= r.left()
                    && this.withinVert(r)
            }
            rubLeft(r) {
                return this.left() > r.right()
                    && this.left() - this.mx <= r.right()
                    && this.withinVert(r)
            }
            landed(r) {
                return this.left() <= r.right()
                    && this.right() >= r.left()
                    && this.bottom() - this.vy <= r.top()
                    && this.bottom() + this.vy >= r.top()
            }
            hitHead(r) {
                return this.left() < r.right()
                    && this.right() > r.left()
                    && this.top() - this.vy >= r.bottom()
                    && this.top() + this.vy <= r.bottom()
            }
            grabStar() {
                this.star_count += 1
                this.energy += 20
                if (this.energy > 100) this.energy = 100
            }
            getFlipAttack(x_click, y_click, ground_boost) {
                let dx = x_click - this.x + this.width / 2
                let dy = y_click - this.y
                if (dx > 0 && dy > 0 && this.energy >= 25) {
                    this.flip_count = this.flip_duration
                    this.flip_rotation = 'clockwise'
                    this.flip_type = 'down'
                    this.facing = 1 // right
                    this.vy = -4-ground_boost
                    this.energy -= 25
                    return true
                } else if (dx > 0 & dy < 0 && this.energy >= 25) {
                    this.flip_count = this.flip_duration
                    this.flip_rotation = 'counter'
                    this.flip_type = 'up'
                    this.facing = 1 // right
                    this.vy = -0.6
                    this.energy -= 25
                    return true
                } else if (dx < 0 & dy > 0 && this.energy >= 25) {
                    this.flip_count = this.flip_duration
                    this.flip_rotation = 'counter'
                    this.flip_type = 'down'
                    this.facing = -1 // left
                    this.vy = -4-ground_boost
                    this.energy -= 25
                    return true
                } else if (this.energy >= 25) {
                    this.flip_count = this.flip_duration
                    this.flip_rotation = 'clockwise'
                    this.flip_type = 'up'
                    this.facing = -1 // left
                    this.vy = -0.6
                    this.energy -= 25
                    return true
                }
            }
        }

        class Enemy extends Rectangle {
            constructor(x, y, width, height, color, vx, vy, target) {
                super(x, y, width, height, color)
                this.vx = vx
                this.vy = vy
                this.target = target
                this.move_cooldown = 30
                this.shot_cooldown = 120
                this.shots = []
            }
            keepDistanceX(min_x, max_x) {
                let x_dist = Math.abs(this.cx() - this.target.cx())
                if (!(x_dist > min_x && x_dist < max_x)) {
                    let dir_switch = x_dist > min_x ? 1 : -1                // INSIDE MIN_X, MOVE AWAY
                    this.x += this.vx * this.getDirX() * dir_switch
                    return true
                }
            }
            proxyX() {
                return Math.abs(this.cx() - this.target.cx())
            }
            proxyY() {
                return Math.abs(this.cy() - this.target.cy())
            }
            getDirX() {
                return this.cx() - this.target.cx() < 0 ? 1 : -1
            }
        }

        class WhiteEnemy extends Enemy {
            constructor(x, y, width, height, color, vx, vy, target) {
                super(x, y, width, height, color, vx, vy, target)
                this.fire_range_x = 600
                this.fire_range_y = 80
                this.segment = 0
                this.segment_dir = 1
                this.range_adj = Math.floor(Math.random() * 40)
            }
            update() {
                if (this.move_cooldown < 0) {
                    this.keepDistanceX(150 + this.range_adj, 250 + this.range_adj)
                    ///// ALIGN Y WITHIN 10 PX /////
                    let ey = this.cy()
                    let ty = this.target.cy()
                    if (this.segment > 0) {
                        this.segment -= 1
                        this.y += this.vy * this.segment_dir
                    } else if (ey > ty + 10) {
                        this.y -= this.vy
                    } else if (ey < ty - 10) {
                        this.y += this.vy
                    } else {
                        this.segment = Math.floor(random(30, 50))
                        this.segment_dir = Math.random() < 0.5 ? 1 : -1
                    }
                }
            }
        }

        class RedEnemy extends Enemy {
            constructor(x, y, width, height, color, vx, vy, target) {
                super(x, y, width, height, color, vx, vy, target)
                this.shot_cooldown = 999
                this.jump_range_x = 300
                this.vx_to_jump = 7
                this.accel_vx = 0.1
                this.jump_vy = -12
                this.on_ground = false
                this.charge_dir = 1
            }
            update(ground_y) {
                ///// SET CHARGE DIRECTION/////
                if (this.move_cooldown === 0) {
                    this.charge_dir = this.getDirX()
                ///// CHARGE /////
                } else if (this.move_cooldown < 0 && this.on_ground) {
                    this.x += this.vx * this.charge_dir
                    if (this.vx < this.vx_to_jump) this.vx += this.accel_vx
                    if (this.vx >= this.vx_to_jump) {
                        if (this.proxyX() < this.jump_range_x) {
                            this.vy = this.jump_vy
                            this.on_ground = false
                        } else if (this.move_cooldown < -240) {
                            this.move_cooldown = 360
                        }
                    }
                ///// AIRBORN /////
                } else if (!this.on_ground) {
                    this.y += this.vy
                    this.vy += 0.4
                    this.vx *= 0.99
                    this.x += this.vx * this.charge_dir
                    if (this.y + this.vy + this.height > ground_y) {
                        this.on_ground = true
                        this.y = ground_y - this.height
                        this.vy = 0
                        this.move_cooldown = 300
                    }
                ///// LANDED /////
                } else {
                    if (this.move_cooldown > 210) {
                        this.x += this.vx * this.charge_dir
                        this.vx *= 0.97
                    } else if(this.move_cooldown === 210) {
                        this.shot_cooldown = Math.floor(random(120, 178))
                        this.vx = 0
                    }
                    if (this.shot_cooldown === -31 || this.shot_cooldown === -16 || this.shot_cooldown === -1) {
                        return true
                    }
                }
            }
        }

        class OrangeEnemy extends Enemy {
            constructor(x, y, width, height, color, vx, vy, target) {
                super(x, y, width, height, color, vx, vy, target)
                this.move_ct = 20
                this.segments = 5
                this.direct_segment = 5
            }
            update() {
                this.move_ct -= 1
                if (this.move_cooldown < 0) {
                    if (this.move_ct < 0) {
                        ///// MOVE = 4-6 RANDOM LENGTHS BETWEEN 30-50 FRAMES /////
                        this.move_ct = Math.floor(random(30, 50))
                        this.segments -= 1
                        if (this.segments === 0) {
                            this.segments = Math.floor(random(4, 7))  //  <-- SET 4-6 SEGMENTS INBETWEEN SHOTS
                            this.move_cooldown = 31
                            this.move_ct += 31
                            ///// CHEAT TOWARDS PLAYER FOR 1 OF THESE SEGMENTS TO ENSURE ENEMY STAYS CLOSE /////
                            this.direct_segment = Math.floor(Math.random() * this.segments) + 1
                            return true
                        }
                        ///// IF FAR AWAY OR ITS THE CHEATER SEGMENT (AND ENEMY ISN'T SUPER CLOSE) /////
                        if (this.proxyX() > 500 || (this.segments === this.direct_segment && this.proxyX() > 150)) {
                                this.vx = Math.abs(this.vx) * this.getDirX()
                        } else {
                            if (Math.random() < 0.5) this.vx *= -1
                        }
                        if (this.y < 30) {
                            this.vy = Math.abs(this.vy)
                        } else if (this.y > 250) {
                            this.vy = -Math.abs(this.vy)
                        } else {
                            if (Math.random() < 0.7) this.vy *= -1
                        }
                    }
                    this.x += this.vx
                    this.y += this.vy
                }
            }
        }

        class YellowEnemy extends Enemy {
            constructor(x, y, width, height, color, vx, vy, target) {
                super(x, y, width, height, color, vx, vy, target)
                this.land_ct = 0
                this.accel_y = 0.5
            }
            update(ground_y) {
                this.land_ct -= 1
                if (this.move_cooldown < 0) {
                    this.y += this.move_cooldown / 30
                    if ((this.y < 100 && Math.random < 0.02) || this.y < 20) {
                        this.vy = 0
                        this.land_ct = 50
                        this.move_cooldown = 360
                    }
                    return true
                } else {
                    if (this.y + this.height < ground_y) {
                        this.y += this.vy
                        this.vy += this.accel_y * (50 - this.land_ct)
                    } else if (this.land_ct > 0) {
                        this.y = ground_y - this.height + 6
                    } else {
                        this.y = ground_y - this.height
                        return true
                   }
                }
            }
        }

        class GreenEnemy extends Enemy {
            constructor(x, y, width, height, color, vx, vy, target) {
                super(x, y, width, height, color, vx, vy, target)
                this.on_ground = false
                this.dir_x = 1
                this.brakes = 1
                this.accel_x = 0.06
                this.shot_cooldown = 9999
                this.shadows = []
            }
            update(ground_y, star_size) {
                let right_dir = this.getDirX()
                let proxy_x = this.proxyX()
                this.x += this.vx
                this.jump_timer -= 1
                if (!this.on_ground) {
                    this.y += this.vy
                    this.vy += 0.4
                    if (this.y + this.vy + this.height > ground_y) {
                        this.on_ground = true
                        this.y = ground_y - this.height
                        this.vy = 0
                    }
                } else if (proxy_x < 350) {
                    if (Math.abs(this.vx) > 6 && proxy_x < 150) {               ///// JUMP
                        this.vx /= 1.8
                        this.vy = -8 - Math.abs(this.vx)
                        this.y += this.vy
                        this.on_ground = false
                        this.jump_timer = 40
                    } else if (Math.abs(this.vx) > 3) {                         ///// ACCELERATE INTO JUMP
                        this.vx += this.accel_x * right_dir * 2
                    } else {                                                    ///// RETREAT
                        this.vx += -this.accel_x * right_dir * 2
                    }
                } else {
                    this.vx += this.accel_x * right_dir
                    if (Math.abs(this.vx) < 0.07) {
                        this.shot_cooldown = Math.floor(random(35, 55))
                        this.vy = -random(12, 15)
                        this.y += this.vy
                        this.on_ground = false
                    } else {
                        this.shot_cooldown = 9999
                    }
                }
                if (this.jump_timer > 0) {
                    if (this.jump_timer % 5 === 0) {
                        let shadow = new Rectangle(this.x, this.y, this.width, this.height, 'lime')
                        shadow.life = 35
                        this.shadows.push(shadow)
                    }
                }
                for (let i=0; i<this.shadows.length; i++) {
                    if (this.shadows[i].width > star_size) this.shadows[i].width -= 0.5
                    if (this.shadows[i].height > star_size) this.shadows[i].height -= 0.5
                }
                return true


                // } else if (this.proxyX() > 70) {
                //     if (this.vx > 0 && right_dir === -1 || this.vx < 0 && right_dir === 1) {
                //         this.brakes = 2
                //     } else {
                //         this.brakes = 1
                //     }


            }
        }

        class BlueEnemy extends Enemy {
            constructor(x, y, width, height, color, vx, vy, target) {
                super(x, y, width, height, color, vx, vy, target)
                this.fire_range_x = 400
                this.runaway_cooldown = 0
                this.runaway_dir = 1
                this.range_adj = Math.floor(Math.random() * 60)
            }
            update() {
                this.runaway_cooldown -= 1
                if (this.move_cooldown < 0) {
                    if (this.y < 30){
                        this.vy = random(0.2, 0.3)
                    } else if (this.y > 70 && this.vy > 0) {
                        this.vy = -random(0.4, 0.8)
                    }
                    if (this.runaway_cooldown > 0) {
                        this.x += this.vx * this.runaway_dir
                    } else if (this.keepDistanceX(200 + this.range_adj, 300 + this.range_adj)) {
                        this.y += this.vy
                    } else {
                        this.y += this.vy * 2
                    }
                }
            }
            goodShot() {
                let theta = Math.atan2(this.target.cy()-this.cy(),this.target.cx()-this.cx()) > 0
                return theta > 0 && this.runaway_cooldown < -200 && this.proxyX() <= 300 + this.range_adj
            }
        }

        class PurpleEnemy extends Enemy {
            constructor(x, y, width, height, color, vx, vy, target) {
                super(x, y, width, height, color, vx, vy, target)
                this.accel_y = 0.2
                this.get_away = false
                this.falling = true
                this.move_cooldown = 300
                this.o_width = width
                this.o_height = height
            }
            update(ground_y, portals) {
                if (this.move_cooldown < 0) {
                    this.height = this.o_height
                    this.width = this.o_width
                    let closest_3_portals = this.getClosest3Portals(ground_y, portals)
                    let target_portal = closest_3_portals[Math.floor(Math.random()*3)]
                    let dx = target_portal.x - this.target.cx()
                    let dy = target_portal.y - this.target.cy()
                    let dist = Math.sqrt(dx**2 + dy**2)
                    this.x = target_portal.x + dx / dist * (target_portal.rad + this.width + 20)
                    this.y = target_portal.y + dy / dist * (target_portal.rad + this.height + 20)
                    this.vy = -1
                    this.falling = true
                    return true
                } else if (this.y < ground_y - this.height) {
                    this.y += this.vy
                    this.vy += this.accel_y
                    if (!this.falling) this.x -= this.vx * this.getDirX()
                } else if (this.move_cooldown < 40) {
                    this.x -= this.vx * this.getDirX()
                    this.width -= .6
                    this.x += .3
                    this.height -= .4
                    this.y = ground_y - this.height
                } else {
                    this.x -= this.vx * this.getDirX()
                    this.y = ground_y - this.height - 0.01
                    this.vy = -random(1.5, 2.5)
                    this.falling = false
                }

            }
            getClosest3Portals(ground_y, portals) {
                let distances = []
                for (let i=0; i<portals.length; i++) {
                    if (portals[i].y < ground_y - 50 && portals[i].y > 50) {
                        let dx = this.target.cx() - portals[i].x
                        let dy = this.target.cy() - portals[i].y
                        let dx_dy_sq = dx ** 2 + dy ** 2
                        distances.push([portals[i], dx_dy_sq])
                    }
                }
                distances.sort((a, b) => a[1] - b[1])
                return [distances[0][0], distances[1][0], distances[2][0]]
            }
        }

        class StarShot extends Rectangle {
            constructor(x, y, width, height, color, shooter, life = 360) {
                super(x, y, width, height, color)
                this.ground_timer = 0
                this.life = life
                this.shooter = shooter
                this.speed = this.speed = color_data[color].shot_speed
            }
        }

        class RedShot extends StarShot {
            constructor(x, y, width, height, color, shooter) {
                super(x, y, width, height, color, shooter)
            }
            update() {
                if (this.target) {
                    let shot_velocities = getShotVelocities(
                        this.target.x + this.target.width / 2, this.target.y + this.target.height / 2,
                        this.x + this.width / 2, this.y + this.height / 2, this.speed)
                    this.vx = (this.vx * 39 + shot_velocities.vx) / 40
                    this.vy = (this.vy * 39 + shot_velocities.vy) / 40
                }
                this.x += this.vx
                this.y += this.vy
            }
        }

        class YellowShot extends StarShot {
            constructor(x, y, width, height, color, shooter, life=360, original=true) {
                super(x, y, width, height, color, shooter, life)
                this.bolt_pivot = {x:0, y:0, life:0}
                this.original = original
                this.split_cooldown = 40
                this.last_dir = Math.random() < 0.5 ? 1 : -1
            }
            update() {
                if (this.life % 15 === 14) {
                    this.bolt_pivot = {x: this.x + this.width/2,
                                       y: this.y + this.height/2, life: 15}
                    let angle_in_rad = Math.atan2(this.vy, this.vx)
                    let rand = random(0.25, 0.40) * this.last_dir
                    this.vx = Math.cos(angle_in_rad + rand) * this.speed
                    this.vy = Math.sin(angle_in_rad + rand) * this.speed
                    this.last_dir *= -1
                    if (this.original) {
                        if (Math.random() < 0.3 && this.split_cooldown < 0) {
                            let shot = new YellowShot(
                                this.x, this.y, this.width, this.height, this.color, this.shooter,
                                    Math.floor(this.life), false)
                            shot.speed = this.speed
                            shot.vx = Math.cos(angle_in_rad - rand) * this.speed
                            shot.vy = Math.sin(angle_in_rad - rand) * this.speed
                            shot.bolt_pivot = this.bolt_pivot
                            this.shooter.shots.push(shot)
                            this.split_cooldown = 35
                        }
                    }
                }
                this.x += this.vx
                this.y += this.vy
                this.split_cooldown -= 1
            }
        }

        class BlueShot extends StarShot {
            constructor(x, y, width, height, color, shooter) {
                super(x, y, width, height, color, shooter)
                this.ct = 0
                this.ice_trail = []
            }
            update() {
                this.ct += 1
                if (this.ice_trail.length > 0) {
                    for (let i = 0; i < this.ice_trail.length; i++) {
                        this.ice_trail[i].life -= 1
                        if (this.ice_trail[i].life === 0) {
                            this.ice_trail.splice(i, 1)
                        } else if (this.ice_trail[i].life < 10) {
                            this.ice_trail[i].color = 'deepskyblue'
                        } else if (this.ice_trail[i].life < 20) {
                            this.ice_trail[i].color = 'dodgerblue'
                        } else {
                            this.ice_trail[i].color = 'blue'
                        }
                    }
                }
                if (this.ct % 5 === 0) {
                    this.ice_trail.push(new Rectangle(this.x, this.y, this.width, this.height, this.color))
                    this.ice_trail[this.ice_trail.length-1].life = 25
                }
                this.x += this.vx
                this.y += this.vy
            }
        }

        let color_data = {
                            //////// PLAYER ////////       //////// ENEMY ////////
            'white':       {shot:           StarShot   ,   enemy:       WhiteEnemy,
                            shot_speed:          6.0   ,   enemy_vx:           1.5,
                            shot_cost:           6.0   ,   enemy_vy:           0.8,
                            mx:                  2.5   ,   width:               10,
                            shield:              0.0   ,   height:              20,
                            bonus:            'none'  },
            'red':         {shot:            RedShot   ,   enemy:         RedEnemy,
                            shot_speed:          7.0   ,   enemy_vx:             0,     // X ACCELERATION IN CONSTRUCTOR
                            shot_cost:          12.0   ,   enemy_vy:             0,     // Y JUMP SPEED IN CONSTRUCTOR
                            mx:                  3.0   ,   width:               30,
                            shield:              2.0   ,   height:              20,
                            bonus:      'mediumblue'  },
            'orange':      {shot:           StarShot   ,   enemy:      OrangeEnemy,
                            shot_speed:          5.5   ,   enemy_vx:           1.5,
                            shot_cost:          12.0   ,   enemy_vy:           0.8,
                            mx:                  2.0   ,   width:               15,
                            shield:              5.0   ,   height:              20,
                            bonus:      'darkorchid'  },
            'yellow':      {shot:         YellowShot   ,   enemy:      YellowEnemy,
                            shot_speed:          8.0   ,   enemy_vx:             0,
                            shot_cost:          10.0   ,   enemy_vy:             0,
                            mx:                  3.5   ,   width:               15,
                            shield:              2.0   ,   height:              30,
                            bonus:       'limegreen'  },
            'limegreen':   {shot:           StarShot   ,   enemy:       GreenEnemy,
                            shot_speed:          9.0   ,   enemy_vx:           2.0,
                            shot_cost:           8.0   ,   enemy_vy:           1.0,
                            mx:                  3.5   ,   width:               15,
                            shield:              2.0   ,   height:              10,
                            bonus:          'yellow'  },
            'mediumblue':  {shot:           BlueShot   ,   enemy:        BlueEnemy,
                            shot_speed:          6.5   ,   enemy_vx:           1.5,
                            shot_cost:          10.0   ,   enemy_vy:          -3.0,
                            mx:                  2.5   ,   width:               30,
                            shield:              4.0   ,   height:              10,
                            bonus:             'red'  },
            'darkorchid':  {shot:           StarShot   ,   enemy:      PurpleEnemy,
                            shot_speed:          7.5   ,   enemy_vx:           1.5,
                            shot_cost:           8.0   ,   enemy_vy:           0.8,
                            mx:                  3.0   ,   width:               25,
                            shield:              4.0   ,   height:              15,
                            bonus:          'orange'  },
        }

        class World {
            constructor(world_cnv, sword_cnv, doc_body) {
                this.doc_body = doc_body
                this.play = true
                this.world_cnv = world_cnv
                this.sword_cnv = sword_cnv
                this.world_ctx = world_cnv.getContext('2d')
                this.sword_ctx = sword_cnv.getContext('2d')
                this.sword_ctx_data = []
                this.cnv_rect = sword_cnv.getBoundingClientRect()
                this.width = sword_cnv.width * 2
                this.height = sword_cnv.height
                this.star_size = 3
                this.player_on_platform = true
                this.ground_height = 20
                this.dv = 0.03
                this.total_velocity = 0
                this.max_velocity = 40
                this.colors = ['red', 'orange', 'yellow', 'limegreen', 'mediumblue', 'darkorchid', 'white']
                this.portals = []
                this.enemies = []
                this.trans_x = 0

                ////// PLATFORMS ///////
                this.platforms = []
                this.ground = new Rectangle(0, this.height - this.ground_height, this.width, this.ground_height, 'green')
                this.platforms.push(this.ground)
                for (let i=0; i<50; i++) {
                    let x = random(10, this.width-10)
                    let y = random(10, this.height-this.ground_height-100)
                    let star = new Rectangle(x, y, this.star_size, this.star_size, 'white')
                    this.platforms.push(star)
                }
                ////// STAR JUMPER!!! ///////
                this.player = new StarJumper(sword_cnv.width/2 - 10, sword_cnv.height-this.ground_height - 20,
                    20, 40, this.colors[color_index])

                ////// HEALTH STAR ///////
                this.health_star = new HealthStar(random(100, this.width - 100), random(0, this.height * 0.8),
                    this.star_size, this.star_size, 'deeppink')

                ////// COLOR LOOP, ENEMIES + PORTALS ///////
                for (let i=0; i<this.colors.length; i++) {
                    this.addEnemy(this.colors[i])                   // ENEMIES
                    let radius = 10 + Math.random() * 10;           // PORTALS
                    let x = random(radius, this.width - radius)
                    let y = random(radius, this.height * 0.8)
                    let p1 = new Portal(x, y, radius, this.colors[i], Math.random()- 0.5, Math.random()- 0.5)
                    x = random(radius, this.width - radius)
                    y = random(radius, this.height * 0.8)
                    let p2 = new Portal(x, y, radius, this.colors[i], Math.random()- 0.5, Math.random()- 0.5)
                    p1.portal_pair = p2
                    p2.portal_pair = p1
                    this.portals.push(p1)
                    this.portals.push(p2)
                }

                ///// LEFT CLICK - SHOOT STAR ///////
                document.body.onclick = (e) => {
                    if (this.player.flip_count <= 0 && this.player.energy >= color_data[this.player.color].shot_cost) {
                        this.player.energy -= color_data[this.player.color].shot_cost
                        ///// WHERE'D PLAYER CLICK /////
                        let clicked_x = e.clientX - this.trans_x - this.cnv_rect.left
                        let clicked_y = e.clientY - this.cnv_rect.top
                        ///// CREATE SHOT BASE /////
                        let shot = new color_data[this.player.color].shot(this.player.cx(), this.player.cy(),
                            this.star_size, this.star_size, this.player.color, this.player)
                        ///// SHOT SPEEDS DETERMINED IN CONSTRUCTOR, USE NOW TO GET VX & VY /////
                        let shot_vel = getShotVelocities(clicked_x, clicked_y,
                            this.player.cx(), this.player.cy(), shot.speed)
                        shot.vx = shot_vel.vx
                        shot.vy = shot_vel.vy

                        ///// SPECIAL CASE - RED & ORANGE /////
                        if (this.player.color === 'red') {
                            shot = this.addRedTarget(clicked_x, clicked_y, this.player, shot)
                            if (this.enemies.length === 0) {
                                let add_back_cost = color_data['red'].shot_cost - color_data['white'].shot_cost
                                this.player.energy += add_back_cost
                            }
                        } else if (this.player.color === 'orange') {
                            this.addOrangeBuck(this.player, shot)
                        }
                        this.player.shots.push(shot)
                    }
                }

                ///// RIGHT CLICK - SWORD SWIPE ///////
                document.body.oncontextmenu = (e) => {
                    if (this.player.flip_count <= 0 && !this.player.staa_ridin) {
                        let ground_boost = Math.max(6 - (this.ground.y - this.player.y) / this.player.height * 2, 0)
                        let result = this.player.getFlipAttack(
                            e.clientX - this.cnv_rect.left - this.trans_x - this.player.width,
                            e.clientY - this.cnv_rect.top, ground_boost)
                        if (result) {
                            // this.sounds[Math.floor(Math.random() * this.sounds.length)].play()
                            this.player.sword_trail.push([])
                            this.player.sword_tip.x = this.player.cx()
                            this.player.sword_tip.y = this.player.cy()
                        }
                    }
                    return false
                }

                ////// SOUNDS ///////
                // this.sounds = []
                // let my_sounds = [
                //     'Neck Breaking-SoundBible.com-933536431.mp3',
                //     'Punch_HD-Mark_DiAngelo-1718986183.mp3',
                //     'Super Punch MMA-SoundBible.com-1869306362.mp3',
                //     'Thwack Hit By Punch-SoundBible.com-872409685.mp3',
                //     'Roundhouse Kick-SoundBible.com-1663225804.mp3',
                //     'Spin Kick-SoundBible.com-1263586030.mp3',
                //     'Kick-SoundBible.com-1331196005.mp3',
                //     'Jab-SoundBible.com-1806727891.mp3',
                //     'Upper Cut-SoundBible.com-1272257235.mp3',
                //     'Right Cross-SoundBible.com-1721311663.mp3',
                //     'Left Hook-SoundBible.com-516660386.mp3',
                //     'Right Hook-SoundBible.com-1406389182.mp3'
                // ]
                // for (let i=0; i<my_sounds.length; i++) {
                //     this.sounds.push(new Sound(my_sounds[i]))
                // }
            }
            addEnemy(color, x=0, y=0) {
                if (x === 0) x = random(400, this.width-400)
                if (y === 0) y = random(50, this.height-this.ground_height-50)
                let enemy = new color_data[color].enemy(
                    x, y, color_data[color].width, color_data[color].height, color,
                    color_data[color].enemy_vx, color_data[color].enemy_vy, this.player)
                this.enemies.push(enemy)
            }
            update() {
                // let temp_ct = 0
                // for (let i=0; i<4800000; i++) {
                //     temp_ct += this.sword_ctx_data[i]
                // }
                // console.log(temp_ct)
                this.trans_x = this.getTransX()
                let pix_data = this.sword_ctx.getImageData(0, 0, this.sword_cnv.width, this.height)
                this.sword_ctx_data = pix_data.data
                let total_velocity = 0
                for (let i = 0; i < this.portals.length; i++) {
                    total_velocity += Math.abs(this.portals[i].vx) + Math.abs(this.portals[i].vy)
                    ///// MOVE PORTAL, SIZE ACCORDING TO PORTAL PAIR /////
                    let portal_pair_position = Math.abs(this.portals[i].portal_pair.x - this.health_star.x) / this.width
                    this.portals[i].update(portal_pair_position)
                    ///// BOUNCE PORTALS OFF SIDES & GROUND //////
                    if (this.portals[i].x + this.portals[i].rad > this.width) {
                        this.portals[i].setRight(this.width)
                        this.portals[i].vx *= -1
                        this.portals[i].x += this.portals[i].vx
                    } else if (this.portals[i].x - this.portals[i].rad < 0) {
                        this.portals[i].setLeft(0)
                        this.portals[i].vx *= -1
                        this.portals[i].x += this.portals[i].vx
                    } else if (this.portals[i].y + this.portals[i].rad > this.height - this.ground_height) {
                        this.portals[i].setBottom(this.height - this.ground_height)
                        this.portals[i].vy *= -1
                        this.portals[i].y += this.portals[i].vy
                    } else if (this.portals[i].y - this.portals[i].rad < 0) {
                        this.portals[i].setTop(0)
                        this.portals[i].vy *= -1
                        this.portals[i].y += this.portals[i].vy
                    }
                    ///// CHECK TO SEE IF PORTAL HIT ANOTHER PORTAL //////
                    for (let j = i+1; j < this.portals.length; ++j) {
                        let result = this.portals[i].checkCollideCir(this.portals[j])
                        let dv = this.total_velocity < this.max_velocity ? this.dv : -this.dv*4
                        if (result && this.portals[i].vib_count <= 0) {
                            this.portals[i].vib_count = 60
                            this.portals[i].vy > 0 ? this.portals[i].vy += dv: this.portals[i].vy -= dv
                            this.portals[i].vx > 0 ? this.portals[i].vx += dv: this.portals[i].vx -= dv
                            this.portals[j].vib_count = 60
                            this.portals[j].vy > 0 ? this.portals[j].vy += dv: this.portals[j].vy -= dv
                            this.portals[j].vx > 0 ? this.portals[j].vx += dv: this.portals[j].vx -= dv
                        }
                    }
                    ///// SEE IF PORTAL HITS PLAYER, EXCEPT LAST PORTAL EXITED //////
                    if (this.portals[i] != this.player.last_teleport) {
                        let hit_player = this.portals[i].checkCollideRec(this.player)
                        if (hit_player) {
                            if (this.player.flip_count > 0) this.player.sword_trail.push([])
                            this.player.vy = 0
                            this.player.color = this.portals[i].color
                            this.player.mx = color_data[this.portals[i].color].mx
                            this.player.rgb = new RGBColor(this.portals[i].color)
                            this.player.last_teleport = this.portals[i].portal_pair
                            this.player.x = this.portals[i].portal_pair.x
                            this.player.y = this.portals[i].portal_pair.y
                        }
                    }
                    ///// SEE IF PORTAL HITS HEALTH STAR, EXCEPT LAST PORTAL EXITED //////
                    if (this.portals[i] != this.health_star.last_teleport) {
                        let hit_health_star = this.portals[i].checkCollideRec(this.health_star)
                        if (hit_health_star) {
                            this.health_star.last_teleport = this.portals[i].portal_pair
                            this.health_star.x = this.portals[i].portal_pair.x
                            this.health_star.y = this.portals[i].portal_pair.y
                            if (this.portals[i].portal_pair.vx > 0) {
                                this.health_star.vx = -Math.abs(this.health_star.vx)
                            } else {
                                this.health_star.vx = Math.abs(this.health_star.vx)
                            }
                            if (this.portals[i].portal_pair.vy > 0) {
                                this.health_star.vy = -Math.abs(this.health_star.vy)
                            } else {
                                this.health_star.vy = Math.abs(this.health_star.vy)
                            }
                        }
                    }
                    ///// REDUCE VIBRATION COUNT //////
                    this.portals[i].vib_count -= 1
                }
                this.total_velocity = total_velocity
                ///// JUMP IF ON PLATFORM ////////
                if ((key_tracker.isKeyDown('ArrowUp') || key_tracker.isKeyDown('w')) && this.player_on_platform) {
                    this.player.vy = -6
                    this.player.y -= 0.3
                    this.player.staa_ridin = false
                }
                ///// DEFAULT ASSUMPTIONS, RESET, INCREMENT, ETC //////
                this.player_on_platform = false
                this.player.star_cooldown -= 1
                this.player.hurt_count -= 1
                let rubbing = false
                if (this.player.energy < 100) this.player.energy += 0.2
                ///// GO RIGHT OR LEFT /////
                if (!this.player.staa_ridin) {
                    if (key_tracker.isKeyDown('ArrowLeft') || key_tracker.isKeyDown('a') || key_tracker.isKeyDown(('A'))) {
                        if (this.player.flip_count <= 0) {
                            this.player.facing = -1 // left
                            ///// CHECK LEFT BUMP /////
                            for (let i = 0; i < this.platforms.length; i++) {
                                if (this.player.rubLeft(this.platforms[i])) {
                                    rubbing = true
                                    break
                                }
                            }
                        }
                        if (!rubbing) this.player.x -= this.player.mx
                        ///// TOO FAR LEFT /////
                        if (this.player.x < 0) this.player.x = 0
                    } else if (key_tracker.isKeyDown('ArrowRight') || key_tracker.isKeyDown('d') || key_tracker.isKeyDown('D')) {
                        if (this.player.flip_count <= 0) {
                            this.player.facing = 1 // right
                            ///// CHECK RIGHT BUMP /////
                            for (let i = 0; i < this.platforms.length; i++) {
                                if (this.player.rubRight(this.platforms[i])) {
                                    rubbing = true
                                    break
                                }
                            }
                        }
                        if (!rubbing) this.player.x += this.player.mx
                        ///// TOO FAR RIGHT /////
                        if (this.player.x + this.player.width > world.width) {
                            this.player.x = world.width - this.player.width
                        }
                    }
                }
                ///// CHECK IF NORMAL STARS ARE INSIDE SWORD TRAIL /////
                for (let i=1; i<this.platforms.length; i++) {
                    if (this.platforms[i].x + this.trans_x < this.world_cnv.width && this.platforms[i].x + this.trans_x > 0) {
                        let sword_hit = this.checkCTX(this.platforms[i])
                        if (sword_hit) {
                            this.platforms.splice(i, 1)
                            this.player.star_count += 1
                        }
                    }
                }
                ///// ENEMIES /////d
                if (this.enemies.length < 7) this.addEnemy(this.colors[Math.floor(Math.random() * this.colors.length)])
                for (let i=0; i<this.enemies.length; i++) {
                    let update_result = false
                    if (!this.enemies[i].dead) {
                        ///// UPDATE BY ENEMY COLOR /////
                        if (this.enemies[i].constructor.name === 'RedEnemy') {
                            update_result = this.enemies[i].update(this.ground.y)
                            if (this.enemies[i].x > this.width - this.enemies[i].width) {
                                this.enemies[i].x = this.width - this.enemies[i].width
                                this.enemies[i].vx = 0
                                this.enemies[i].move_cooldown = 240
                            } else if (this.enemies[i].x < 0) {
                                this.enemies[i].x = 0
                                this.enemies[i].vx = 0
                                this.enemies[i].move_cooldown = 240
                            }
                        } else if (this.enemies[i].constructor.name === 'YellowEnemy') {
                            update_result = this.enemies[i].update(this.ground.y)
                            if (this.enemies[i].proxyX() < 100) {
                                this.enemies[i].shot_cooldown -= 2
                            } else if (this.enemies[i].proxyX() < 200) {
                                this.enemies[i].shot_cooldown -= 1
                            }
                        } else if (this.enemies[i].constructor.name === 'GreenEnemy') {
                            update_result = this.enemies[i].update(this.ground.y, this.star_size)
                            if (this.enemies[i].x > this.width - this.enemies[i].width) {
                                this.enemies[i].x = this.width - this.enemies[i].width
                                this.enemies[i].vx = -8
                            } else if (this.enemies[i].x < 0) {
                                this.enemies[i].x = 0
                                this.enemies[i].vx = 8
                            }
                            ///// CHECK COLLISION WITH SHADOW /////
                            if (this.player.hurt_count < 0) {
                                for (let j=0; j<this.enemies[i].shadows.length; j++) {
                                    if (this.enemies[i].shadows[j].checkCollideRec(this.player)) {
                                        this.player.health -= 1
                                        this.player.hurt_count = 120
                                        this.enemies[i].shadows.splice(j, 1)
                                    }
                                }
                            }
                        } else if (this.enemies[i].constructor.name === 'BlueEnemy') {
                            this.enemies[i].update()
                            if (this.enemies[i].x > this.width - this.enemies[i].width) {
                                this.enemies[i].x = this.width - this.enemies[i].width
                                this.enemies[i].runaway_cooldown = 180
                                this.enemies[i].runaway_dir = -1
                            } else if (this.enemies[i].x < 0) {
                                this.enemies[i].x = 0
                                this.enemies[i].runaway_cooldown = 180
                                this.enemies[i].runaway_dir = 1
                            }
                        } else if (this.enemies[i].constructor.name === 'PurpleEnemy') {
                            update_result = this.enemies[i].update(this.ground.y, this.portals)
                        } else if (this.enemies[i].constructor.name === 'WhiteEnemy') {
                            update_result = this.enemies[i].update()
                            if (this.enemies[i].y > this.ground.y - this.enemies[i].height) {
                                this.enemies[i].segment_dir *= -1
                            }
                        } else {
                            update_result = this.enemies[i].update()
                        }
                        ///// CHECK ON SWORD /////
                        let sword_hit = this.checkCTX(this.enemies[i])
                        if (sword_hit) {
                            this.enemies[i].dead = true
                            this.player.score += 1
                        } else {
                            ///// CHECK IF PLAYER SHOTS HIT ENEMY /////
                            for (let j = 0; j < this.player.shots.length; j++) {
                                if (this.player.shots[j].checkCollideRec(this.enemies[i])) {
                                    this.enemies[i].dead = true
                                    this.player.score += 1
                                    this.player.shots.splice(j, 1)
                                    break
                                ///// CHECK BLUE SHOT ICE TRAILS /////
                                } else if (this.player.shots[j].ice_trail) {
                                    for (let k = 0; k < this.player.shots[j].ice_trail.length; k++) {
                                        if (this.player.shots[j].ice_trail[k].checkCollideRec(this.enemies[i])) {
                                            this.enemies[i].dead = true
                                            this.player.score += 1
                                            this.player.shots.splice(j, 1)
                                            break
                                        }
                                    }
                                }
                            }
                            ///// IF ENEMY AND PLAYER COLLIDE, SUBTRACT HEALTH /////
                            if (this.player.hurt_count < 0) {
                                if (this.enemies[i].checkCollideRec(this.player)) {
                                    this.enemies[i].dead = true
                                    this.player.health -= 1
                                    this.player.hurt_count = 120
                                }
                            }
                        }
                    }
                    ///// ENEMY STILL ALIVE, TAKE DIRECT SHOT IF RANDOM CHANCE + AFTER COOLDOWN /////
                    if (!this.enemies[i].dead) {
                        this.enemies[i].shot_cooldown -= 1
                        this.enemies[i].move_cooldown -= 1
                        if (update_result || Math.random() < 0.02) {
                            let take_shot = true
                            if (this.enemies[i].constructor.name === 'WhiteEnemy') {
                                take_shot = this.enemies[i].proxyX() < this.enemies[i].fire_range_x
                                take_shot = this.enemies[i].proxyY() < this.enemies[i].fire_range_y
                            } else if (this.enemies[i].constructor.name === 'RedEnemy'
                                || this.enemies[i].constructor.name === 'OrangeEnemy'
                                || this.enemies[i].constructor.name === 'YellowEnemy'
                                || this.enemies[i].constructor.name === 'PurpleEnemy') {
                                    take_shot = update_result
                            } else if (this.enemies[i].constructor.name === 'BlueEnemy') {
                                take_shot = this.enemies[i].goodShot()
                                if (take_shot) {
                                    this.enemies[i].runaway_cooldown = 180
                                    this.enemies[i].move_cooldown = 30
                                    if (this.enemies[i].cx() < this.player.cx()) {
                                        this.enemies[i].runaway_dir = -1
                                    } else {
                                        this.enemies[i].runaway_dir = 1
                                    }
                                }
                            }
                            if (take_shot && this.enemies[i].shot_cooldown < 0) {
                                let shot = new color_data[this.enemies[i].color].shot(
                                    this.enemies[i].cx(), this.enemies[i].cy(), this.star_size, this.star_size,
                                    this.enemies[i].color, this.enemies[i])
                                let shot_vel = getShotVelocities(this.player.cx(), this.player.cy(),
                                    this.enemies[i].cx(), this.enemies[i].cy(), shot.speed)
                                shot.vx = shot_vel.vx
                                shot.vy = shot_vel.vy
                                ///// SPECIAL CASES - RED & ORANGE /////
                                if (this.enemies[i].constructor.name === 'RedEnemy') {
                                    if (this.enemies[i].proxyX() < 200) {
                                        shot.vx = 0
                                        shot.vy = -7
                                    } else if (this.enemies[i].cx() < this.player.cx()) {
                                        shot.vx = 3.3
                                        shot.vy = -6
                                    } else {
                                        shot.vx = -3.3
                                        shot.vy = -6
                                    }
                                    shot = this.addRedTarget(
                                        this.enemies[i].cx(), this.enemies[i].cy(), this.enemies[i], shot)
                                } else if (this.enemies[i].constructor.name === 'OrangeEnemy') {
                                    this.addOrangeBuck(this.enemies[i], shot)
                                    this.enemies[i].move_cooldown = 30
                                } else if (this.enemies[i].constructor.name === 'YellowEnemy') {
                                    this.enemies[i].shot_cooldown = Math.floor(random(45, 75))
                                    shot.vy = 0
                                    if (Math.random() < 0.5) {
                                        shot.last_dir = -1
                                        shot.vx = 4
                                    } else {
                                        shot.last_dir = 1
                                        shot.vx = -4
                                    }
                                } else if (this.enemies[i].constructor.name === 'PurpleEnemy') {
                                    this.enemies[i].move_cooldown = Math.floor(random(200, 320))
                                } else if (this.enemies[i].constructor.name === 'WhiteEnemy') {
                                    this.enemies[i].segment = 0
                                    this.enemies[i].move_cooldown = 60
                                    this.enemies[i].shot_cooldown = 120
                                } else {
                                    this.enemies[i].move_cooldown = 60
                                    this.enemies[i].shot_cooldown = 120
                                }
                                shot.life = 240
                                this.enemies[i].shots.push(shot)
                            }
                        }
                    }
                    ///// UPDATE ENEMY'S SHOTS /////
                    for (let j=0; j<this.enemies[i].shots.length; j++) {
                        this.enemies[i].shots[j].update()
                        ///// OFF WORLD /////
                        if (this.enemies[i].shots[j].x < 0 || this.enemies[i].shots[j].x > this.width ||
                            this.enemies[i].shots[j].y < 0 || this.enemies[i].shots[j].y > this.height) {
                                this.enemies[i].shots.splice(j, 1)
                            continue
                        }
                        ///// CHECK ON SWORD /////
                        let sword_hit = this.checkCTX(this.enemies[i].shots[j])
                        if (sword_hit) {
                            let shot = new StarShot(
                                this.enemies[i].shots[j].x, this.enemies[i].shots[j].y,
                                this.star_size, this.star_size, this.player.color, this.player, 180)
                            shot.vx = -this.enemies[i].shots[j].vx * 1
                            shot.vy = -this.enemies[i].shots[j].vy * 1
                            this.player.shots.push(shot)
                            this.enemies[i].shots.splice(j, 1)
                        } else {
                            ///// SLOW SHOTS /////
                            this.enemies[i].shots[j].vx *= 0.994
                            this.enemies[i].shots[j].vy *= 0.994
                            this.enemies[i].shots[j].speed *= 0.994
                            this.enemies[i].shots[j].life -= 1
                            ///// REMOVE EXPIRED OR INFLATE IF NEAR DEATH /////
                            if (this.enemies[i].shots[j].life === 0) {
                                this.enemies[i].shots.splice(j, 1)
                            } else if (this.enemies[i].shots[j].life < 30) {
                                this.enemies[i].shots[j].width += 4 / this.enemies[i].shots[j].life
                                this.enemies[i].shots[j].height += 4 / this.enemies[i].shots[j].life
                                this.enemies[i].shots[j].x -= 2 / this.enemies[i].shots[j].life
                                this.enemies[i].shots[j].y -= 2 / this.enemies[i].shots[j].life
                            }
                            ///// CHECK HIT ON PURPLE PORTAL & ON STAR JUMPER /////
                            if (this.enemies[i].shots[j]) {
                                this.checkPurpleShot(this.enemies[i], this.enemies[i].shots[j], j)
                                ///// IF YOU'RE NOT HURT /////
                                if (this.player.hurt_count < 0) {
                                    if (this.enemies[i].shots[j].checkCollideRec(this.player)) {
                                        if (this.player.health > 0) this.player.health -= 1
                                        this.player.hurt_count = 120
                                        this.enemies[i].shots.splice(j, 1)
                                    ///// CHECK BLUE SHOT ICE TRAILS /////
                                    } else if (this.enemies[i].shots[j].ice_trail) {
                                        for (let k = 0; k < this.enemies[i].shots[j].ice_trail.length; k++) {
                                            if (this.enemies[i].shots[j].ice_trail[k].checkCollideRec(this.player)) {
                                                if (this.player.health > 0) this.player.health -= 1
                                                this.player.hurt_count = 120
                                                this.enemies[i].shots.splice(j, 1)
                                                break
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                    if (this.enemies[i].dead && this.enemies[i].shots.length === 0) this.enemies.splice(i, 1)
                }
                ///// BOUNCE POINT STAR //////
                let is_ob_right = this.health_star.x + this.health_star.width > this.width
                let is_ob_left = this.health_star.x < 0
                if (is_ob_right || is_ob_left) this.health_star.vx *= -1
                let is_ob_top = this.health_star.y > this.height - this.ground.height - this.star_size
                let is_ob_bottom = this.health_star.y < 0
                if (is_ob_top || is_ob_bottom) this.health_star.vy *= -1
                ///// IF RIDING ON HEALTH STAR /////
                this.health_star.update()
                if (this.player.staa_ridin) {
                    this.player_on_platform = true
                    this.player.x = this.health_star.x - (this.player.width - this.star_size) / 2
                    this.player.y = this.health_star.y - this.player.height
                    ///// PICK UP HEALTH STAR  /////
                    if (key_tracker.isKeyDown('ArrowDown') || key_tracker.isKeyDown('s')) {
                        this.player.staa_ridin = false
                        this.player_on_platform = false
                        this.player.star_cooldown = 10
                        this.player.health += 3
                        this.health_star.x = random(0, this.width - this.star_size)
                        this.health_star.y = random(0, this.height - this.star_size - this.ground_height)
                        this.health_star.setRandomVelocities()
                    }
                ///// IF YOU LAND ON THE HEALTH STAR /////
                } else if (this.player.landed(this.health_star) && !this.player.staa_ridin) {
                    this.player_on_platform = true
                    this.player.staa_ridin = true
                    this.player.flip_count = 0
                ///// IF YOU ARE FLIPPING, UP OR DOWN /////
                } else if (this.player.flip_count > 0) {
                    if (this.player.flip_type === 'up') {
                        this.player.vy -= 0.08
                    } else {
                        this.player.vy += 0.5
                    }
                    this.player.y += this.player.vy
                    if (this.player.y + this.player.height + this.ground.height >= this.height) {
                        this.player.y = this.height - this.player.height - this.ground.height
                        this.player.flip_count = 0
                    } else {
                        this.player.flip_count -= 1
                    }
                ///// OTHERWISE CHECK NORMAL HITS /////
                } else {
                    for (let i=0; i<this.platforms.length; i++) {
                        ///// LANDED ON STAR OR GROUND /////
                        if (this.player.landed(this.platforms[i])) {
                            this.player.y = this.platforms[i].top() - this.player.height
                            this.player.vy = 0
                            this.player_on_platform = true
                            ///// DOWN KEY = PICK UP STAR /////
                            if ((key_tracker.isKeyDown('ArrowDown') || key_tracker.isKeyDown('s'))
                                && this.platforms[i] != this.ground && this.player.star_cooldown < 0) {
                                    this.player.star_cooldown = 10
                                    this.player.grabStar()
                                    this.platforms.splice(i, 1)
                            }
                            break
                        ///// CHECK HEAD BUMP /////
                        } else if (this.player.hitHead(this.platforms[i]) && this.player.vy < 0
                            && this.platforms[i] != this.ground && this.player.flip_count <= 0) {
                                this.player.y = this.platforms[i].bottom() + 0.001
                                this.player.vy = -0.015
                                break
                        }
                    }
                }
                ///// UPDATE STAR SHOTS /////
                for (let i=0; i<this.player.shots.length; i++) {
                    ///// UPDATE & BOUNCE SHOTS IN PLAY /////
                    if (this.player.shots[i].ground_timer === 0) {
                        ///// REMOVE EXPIRED STAR SHOTS
                        if (this.player.shots[i].life === 0) {
                            this.player.shots.splice(i, 1)
                        } else {
                            this.player.shots[i].update()
                            if (this.player.shots[i].life < 30) {
                                this.player.shots[i].width += 4 / this.player.shots[i].life
                                this.player.shots[i].height += 4 / this.player.shots[i].life
                                this.player.shots[i].x -= 2 / this.player.shots[i].life
                                this.player.shots[i].y -= 2 / this.player.shots[i].life
                            }
                            ///// SLOW SHOTS IN PLAY /////
                            this.player.shots[i].life -= 1
                            this.player.shots[i].vx *= 0.994
                            this.player.shots[i].vy *= 0.994
                            this.player.shots[i].speed *= 0.994
                            if (this.player.shots[i]) this.checkPurpleShot(this.player, this.player.shots[i], i)
                        }
                    ///// REMOVE INFLATED SHOTS THAT HAVE REACHED 1 /////
                    } else if (this.player.shots[i].ground_timer === 1) {
                        this.player.shots.splice(i, 1)
                    ///// INFLATE STARS THAT HAVE HIT GROUND /////
                    } else {
                        this.player.shots[i].ground_timer -= 1
                        this.player.shots[i].height += 0.6
                        this.player.shots[i].width += 0.6
                        this.player.shots[i].y = this.height - this.ground_height - this.player.shots[i].height
                        this.player.shots[i].x -= 0.3
                    }
                }
                ///// MID AIR SCENARIOS - NOT ON A PLATFORM OR HEALTH STAR, NOT FLIPPING /////
                if (!this.player_on_platform && !this.player.staa_ridin && this.player.flip_count <= 0) {
                    this.player.vy += 0.2
                    this.player.y += this.player.vy
                    ///// CHECK GROUND BOUNCE /////
                    if (this.player.y + this.player.height + this.ground.height >= this.height) {
                        this.player.y = this.height - this.player.height - this.ground.height
                    }
                    ///// HIT DOWN KEY, S, OR SPACE TO ADD STAR UNDER STAR JUMPER /////
                    if ((key_tracker.isKeyDown(' ') || key_tracker.isKeyDown('s'))
                        && this.player.star_count > 0 && this.player.star_cooldown < 0) {
                            let new_star_x = this.player.x + (this.player.width - this.star_size) / 2
                            let new_star_y = this.player.y + this.player.height
                            let star = new Rectangle(new_star_x, new_star_y, this.star_size, this.star_size, 'white')
                            this.platforms.push(star)
                            this.player.vy = 0
                            this.player.star_cooldown = 10
                            this.player.star_count -= 1
                    }
                }
            }
            checkCTX(r) {
                if (r.width + r.height < 20) {
                    ///// CHECK CENTER OF SMALL RECTANGLES /////
                    let x = Math.round(r.cx() + this.trans_x)
                    let y = Math.round(r.cy())
                    if (this.sword_ctx_data[(4 * this.sword_cnv.width * (y - 1)) + (4 * x) - 1] > 0) {
                        return true
                    }
                } else {
                    ///// CHECK EACH CORNER OF LARGER RECTANGLES /////
                    let x = Math.round(r.x + this.trans_x)
                    let y = Math.round(r.y)
                    let top_left =      (4 * this.sword_cnv.width * (y - 1))            + (4 * x) - 1
                    let top_right =     (4 * this.sword_cnv.width * (y - 1))            + (4 * (x + r.width)) - 1
                    let bottom_left =   (4 * this.sword_cnv.width * (y + r.height - 1)) + (4 * x) - 1
                    let bottom_right =  (4 * this.sword_cnv.width * (y + r.height - 1)) + (4 * (x + r.width)) - 1
                    if (this.sword_ctx_data[top_left] > 0) {
                        return true
                    } else if (this.sword_ctx_data[top_right] > 0) {
                        return true
                    } else if (this.sword_ctx_data[bottom_left] > 0) {
                        return true
                    } else if (this.sword_ctx_data[bottom_right] > 0) {
                        return true
                    }
                    return false
                }
                return false
            }
            draw() {
                this.world_ctx.clearRect(0, 0, this.world_cnv.width, this.world_cnv.height)
                this.sword_ctx.clearRect(0, 0, this.sword_cnv.width, this.sword_cnv.height)
                this.world_ctx.lineWidth = 2
                this.world_cnv.style.backgroundPositionX = this.trans_x + 'px'
                this.sword_cnv.style.backgroundPositionX = this.trans_x + 'px'
                this.world_ctx.translate(this.trans_x, 0)
                this.sword_ctx.translate(this.trans_x, 0)

                for (let i=0; i<this.platforms.length; i++) {
                    this.platforms[i].draw(this.world_ctx)
                }
                for (let i=0; i<this.enemies.length; i++) {
                    if (!this.enemies[i].dead) this.enemies[i].draw(this.world_ctx)
                    if (this.enemies[i].shadows) {
                        for (let j=0; j<this.enemies[i].shadows.length; j++) {
                            this.enemies[i].shadows[j].draw(this.world_ctx)
                            this.enemies[i].shadows[j].life -= 1
                            if (this.enemies[i].shadows[j].life === 0) this.enemies[i].shadows.splice(j, 1)
                        }
                    }
                    for (let j=0; j<this.enemies[i].shots.length; j++) {
                        this.enemies[i].shots[j].draw(this.world_ctx)
                        this.checkExtraDraw(this.enemies[i].shots[j])
                    }
                }
                for (let i=0; i<this.player.shots.length; i++) {
                    this.player.shots[i].draw(this.world_ctx)
                    this.checkExtraDraw(this.player.shots[i])
                }
                for (let i=0; i<this.portals.length; i++) {
                    if (this.portals[i].vib_count > 0) {
                        if (this.portals[i].vib_count % 4 < 2) {
                            this.portals[i].rad += 2
                            this.portals[i].draw(this.world_ctx)
                            this.portals[i].rad -= 2
                        } else {
                            this.portals[i].draw(this.world_ctx)
                        }
                    } else {
                        this.portals[i].draw(this.world_ctx)
                    }
                }
                this.player.draw(this.world_ctx, this.sword_ctx, this.ground.y)
                this.health_star.draw(this.world_ctx)

                this.world_ctx.resetTransform()
                this.sword_ctx.resetTransform()

                this.world_ctx.fillStyle = "white"
                this.world_ctx.font = "bolder 24px Arial"
                this.world_ctx.fillText('Stars: ', this.world_cnv.width - 104, 24)
                this.world_ctx.fillText(this.player.star_count, this.world_cnv.width - 32, 24)
                this.world_ctx.fillText('Score: ', this.world_cnv.width - 111, 48)
                this.world_ctx.fillText(this.player.score, this.world_cnv.width - 32, 48)

                let status_bar_left = this.world_cnv.width * 0.25
                let status_bar_width = this.world_cnv.width * 0.5
                let player_position_in_world = (this.player.cx()) / this.width
                let player_status_bar_position = status_bar_width * player_position_in_world + status_bar_left
                let health_star_position_in_world = (this.health_star.x + this.health_star.width / 2) / this.width
                let health_star_status_bar_position = status_bar_width * health_star_position_in_world + status_bar_left

                this.world_ctx.beginPath()
                this.world_ctx.moveTo(status_bar_left, 15)
                this.world_ctx.lineTo(status_bar_left + status_bar_width, 15)
                this.world_ctx.strokeStyle = 'white'
                this.world_ctx.stroke()

                this.world_ctx.lineWidth = 5
                this.world_ctx.beginPath()
                this.world_ctx.moveTo(player_status_bar_position, 7)
                this.world_ctx.lineTo(player_status_bar_position, 23)
                this.world_ctx.strokeStyle = this.player.color
                this.world_ctx.stroke()

                this.world_ctx.beginPath()
                this.world_ctx.moveTo(health_star_status_bar_position, 3)
                this.world_ctx.lineTo(health_star_status_bar_position, 27)
                this.world_ctx.strokeStyle = this.health_star.color
                this.world_ctx.stroke()
                
                ///// HEALTH /////
                this.world_ctx.lineWidth = 20
                this.world_ctx.font = "bold 16px Arial"
                this.world_ctx.fillStyle = "black"
                let display_health = Math.min(this.player.health, 100)
                this.world_ctx.beginPath()
                this.world_ctx.moveTo(6, 16)
                this.world_ctx.lineTo(6 + display_health, 16)
                this.world_ctx.strokeStyle = 'rgba(255, 0, 0, 0.8)'
                this.world_ctx.stroke()
                ///// GREY BAR BEHIND HEALTH /////
                this.world_ctx.beginPath()
                this.world_ctx.moveTo(6 + display_health, 16)
                this.world_ctx.lineTo(6 + this.player.base_health, 16)
                this.world_ctx.strokeStyle = 'rgba(150, 150, 150, 0.8)'
                this.world_ctx.stroke()
                ///// HEALTH TEXT /////
                let add_left = display_health < 100 ? 8 : 0
                this.world_ctx.fillText('Health:', 13, 22)
                this.world_ctx.fillText(Math.round(this.player.health), 76 + add_left, 22)
                
                ///// ENERGY /////
                let display_energy = Math.min(this.player.energy, 100)
                this.world_ctx.beginPath()
                this.world_ctx.moveTo(6, 40)
                this.world_ctx.lineTo(6 + display_energy, 40)
                this.world_ctx.strokeStyle = 'rgba(20, 20, 255, 0.8)'
                this.world_ctx.stroke()
                ///// GREY BAR BEHIND ENERGY /////
                this.world_ctx.beginPath()
                this.world_ctx.moveTo(6 + display_energy, 40)
                this.world_ctx.lineTo(6 + this.player.base_energy, 40)
                this.world_ctx.strokeStyle = 'rgba(150, 150, 150, 0.8)'
                this.world_ctx.stroke()
                ///// ENERGY TEXT /////
                add_left = display_energy < 100 ? 8 : 0
                this.world_ctx.fillText('Energy:', 13, 46)
                this.world_ctx.fillText(Math.round(this.player.energy), 76 + add_left, 46)

                // this.world_ctx.fillText('portal speeds: ' + Math.round(this.total_velocity*10)/10, 70, 45)
                // this.world_ctx.fillText('time elapsed: ' +
                //         Math.floor((this.current - this.start)/60000) + ":" +                       // MINUTES //
                //         ("0" + Math.floor((this.current - this.start) / 1000) % 60).slice(-2),      // SECONDS //
                //         70, 60)
            }
            checkExtraDraw(shot) {
                if (shot.bolt_pivot) {
                    if (shot.bolt_pivot.life > 0) {
                        this.world_ctx.lineWidth = 3
                        this.world_ctx.beginPath()
                        this.world_ctx.moveTo(shot.bolt_pivot.x, shot.bolt_pivot.y)
                        this.world_ctx.lineTo(shot.cx(), shot.cy())
                        let grd = this.world_ctx.createLinearGradient(
                            shot.bolt_pivot.x, shot.bolt_pivot.y, shot.x, shot.y)
                        grd.addColorStop("0", "rgba(0,0,0,0)")
                        grd.addColorStop("1", shot.color)
                        this.world_ctx.strokeStyle = grd
                        this.world_ctx.stroke()
                        shot.bolt_pivot.life -= 1
                    }
                } else if (shot.ice_trail) {
                    for (let j=0; j<shot.ice_trail.length; j++) {
                        shot.ice_trail[j].draw(this.world_ctx)
                    }
                }
            }
            addOrangeBuck(shooter, shot) {
                let angle_in_rad = Math.atan2(shot.vy, shot.vx)
                ///// 2 MINI-SHOT LOOP /////
                for (let i=0; i<2; i++) {
                    ///// 1ST MINI-SHOT CLOCKWISE, 2ND COUNTER-CLOCKWISE /////
                    let rand = (i === 0) ? random(0.1, 0.15) : random(-0.15, -0.1)
                    let mini_v = {vx: Math.cos(angle_in_rad + rand),
                                  vy: Math.sin(angle_in_rad + rand)}
                    let mini_shot = new StarShot(shot.x, shot.y, this.star_size, this.star_size, 'orange', this.player, 180)
                    ///// WEAKER MINI-SHOTS THAN MAIN SHOT /////
                    rand = random(2.5, 3)
                    mini_shot.vx = mini_v.vx * rand
                    mini_shot.vy = mini_v.vy * rand
                    shooter.shots.push(mini_shot)
                }
            }
            addRedTarget(x, y, shooter, shot, portal=false) {
                if (this.enemies.length > 0) {
                    if (shooter === this.player) {
                        shot.target = getClosestTarget(x, y, this.enemies)
                    } else {
                        shot.target = this.player
                    }
                } else {
                    ///// CHANGE TO REGULAR SHOT IF NO TARGETS /////
                    let save_vx = shot.vx  // AT LEAST KEEP IT RED-FAST
                    let save_vy = shot.vy  // AT LEAST KEEP IT RED-FAST
                    if (!portal) {
                        x = shooter.cx()
                        y = shooter.cy()
                    }
                    shot = new StarShot(x, y, this.star_size, this.star_size, 'red', this.player)
                    shot.vx = save_vx
                    shot.vy = save_vy
                }
                return shot
            }
            checkPurpleShot(shooter, shot, index) {
                ///// BOUNCE OFF BOUNDARIES /////
                if (shot.color === 'darkorchid') {
                    if (shot.x > this.width - this.star_size) {
                        shot.vx *= -1
                        shot.x = this.width - this.star_size - shot.vx
                    } else if (shot.x < 0) {
                        shot.vx *= -1
                        shot.x = shot.vx
                    } else if (shot.y < 0) {
                        shot.vy *= -1
                        shot.y += shot.vy
                    } else if (shot.y + this.star_size > this.height - this.ground_height) {
                        shot.vy *= -1
                        shot.y = this.height - this.star_size - this.ground_height + shot.vy
                    }
                    ///// COLLISION WITH PORTALS = CHANGE SHOT TYPE /////
                    for (let j = 0; j < this.portals.length; j++) {
                        if (this.portals[j].checkCollideRec(shot)) {
                            let new_shot = new color_data[this.portals[j].color].shot(
                                shot.x, shot.y, this.star_size, this.star_size, this.portals[j].color, shooter)
                            let shot_vel = getShotVelocities(
                                shot.vx, shot.vy, 0, 0, color_data[this.portals[j].color].shot_speed)
                            new_shot.vx = shot_vel.vx
                            new_shot.vy = shot_vel.vy
                            ///// SPECIAL CASES - RED & ORANGE /////
                            if (this.portals[j].color === 'red') {
                                new_shot = this.addRedTarget(new_shot.x, new_shot.y, shooter, new_shot, true)
                            } else if (this.portals[j].color === 'orange') {
                                this.addOrangeBuck(shooter, new_shot)
                            }
                            shooter.shots.push(new_shot)
                            shooter.shots.splice(index, 1)
                            break
                        }
                    }
                } else if (shot.y + this.star_size > this.height - this.ground_height) {
                    shot.y = this.height + this.star_size + this.ground_height
                    shot.ground_timer = 30
                }
            }
            getTransX() {
                // trans_x is how far left to shift to get the right part of the world into view
                let trans_x = -this.player.x + this.world_cnv.width/2
                // if the adjustment would go past the end of the world...
                if (trans_x > 0) {
                    return  0
                } else if (trans_x < -this.width + this.world_cnv.width) {
                    return -this.width + this.world_cnv.width
                }
                return trans_x
            }
        }

        class Portal {
            constructor(x, y, radius, color, vx=0, vy=0) {
                this.x = x
                this.y = y
                this.vx = vx
                this.vy = vy
                this.rad = radius
                this.color = color
                this.vib_count = 0
            }
            draw(world_ctx) {
                let grd = world_ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, this.rad);
                grd.addColorStop(0, 'transparent');
                grd.addColorStop(1, this.color);
                world_ctx.beginPath()
                world_ctx.arc(this.x, this.y, this.rad, 0, 2 * Math.PI, false)
                world_ctx.fillStyle = grd;
                world_ctx.fill();
            }
            update(rad_multi) {
                this.rad = 10 + rad_multi * 20
                this.x += this.vx
                this.y += this.vy
            }
            checkCollideRec(rec) {
                let dx = this.x - (rec.x + rec.width / 2)
                let dy = this.y - (rec.y + rec.height / 2)
                let x_width = (this.rad*2 + rec.width) / 2
                let x_height = (this.rad*2 + rec.height) / 2
                return Math.abs(dx) <= x_width && Math.abs(dy) <= x_height
            }
            checkCollideCir(cir) {
                let change_in_x = this.x - cir.x
                let change_in_y = this.y - cir.y
                let separation2 = change_in_x*change_in_x + change_in_y * change_in_y
                let combo_len = this.rad + cir.rad
                let combo_len2 = combo_len * combo_len
                if (separation2 <= combo_len2) {
                    let separation = Math.sqrt(separation2)
                    // YOUR BALLS ARE TOUCHING, SEPARATE THEM
                    let diff = combo_len - separation
                    let nudge = diff / 2
                    let x_part_of_separation = (change_in_x / separation) ** 2
                    let y_part_of_separation = (change_in_y / separation) ** 2
                    let nudge_x = nudge * x_part_of_separation
                    let nudge_y = nudge * y_part_of_separation
                    // NUDGE YOUR BALLS BACK TO TOUCHING EDGES
                    this.x -= nudge_x
                    this.y -= nudge_y
                    cir.x += nudge_x
                    cir.y += nudge_y
                    // CALCULATE NEW VELOCITIES
                    let collision_angle = Math.atan2(cir.y - this.y, cir.x - this.x)
                    let vel_vect_len_i = Math.sqrt(this.vx ** 2 + this.vy ** 2)
                    let vel_vect_len_j = Math.sqrt(cir.vx ** 2 + cir.vy ** 2)
                    if (vel_vect_len_i + vel_vect_len_j > 0) {
                        let direction_i = Math.atan2(this.vy, this.vx)
                        let direction_j = Math.atan2(cir.vy, cir.vx)
                        let vx_new_plane_i = vel_vect_len_i * Math.cos(direction_i - collision_angle)
                        let vy_new_plane_i = vel_vect_len_i * Math.sin(direction_i - collision_angle)
                        let vx_new_plane_j = vel_vect_len_j * Math.cos(direction_j - collision_angle)
                        let vy_new_plane_j = vel_vect_len_j * Math.sin(direction_j - collision_angle)
                        let vx_final_i = ((this.rad - cir.rad) * vx_new_plane_i + (cir.rad + cir.rad) * vx_new_plane_j) / (this.rad + cir.rad)
                        let vx_final_j = ((this.rad + this.rad) * vx_new_plane_i + (cir.rad - this.rad) * vx_new_plane_j) / (this.rad + cir.rad)
                        let cosAngle = Math.cos(collision_angle)
                        let sinAngle = Math.sin(collision_angle)
                        this.vx = cosAngle * vx_final_i - sinAngle * vy_new_plane_i
                        this.vy = sinAngle * vx_final_i + cosAngle * vy_new_plane_i
                        cir.vx = cosAngle * vx_final_j - sinAngle * vy_new_plane_j
                        cir.vy = sinAngle * vx_final_j + cosAngle * vy_new_plane_j
                        // MOVE IN NEW DIRECTION ONE TICK
                        this.x += this.vx
                        this.y += this.vy
                        cir.x += cir.vx
                        cir.y += cir.vy
                    }
                    return true
                }
                return false
            }
            setLeft(x) {
                this.x = x + this.rad
            }
            setRight(x) {
                this.x = x - this.rad
            }
            setTop(y) {
                this.y = y + this.rad
            }
            setBottom(y) {
                this.y = y - this.rad
            }
        }

        class HealthStar extends Rectangle {
            constructor(x, y, width, height, color) {
                super(x, y, width, height, color);
                this.setRandomVelocities()
                this.last_teleport = {}
            }
            setRandomVelocities() {
                let rand_vx = random(0.5, 1) * (Math.random < 0.5 ? -1 : 1)
                let rand_vy = random(0.5, 1) * (Math.random < 0.5 ? -1 : 1)
                this.vx = rand_vx
                this.vy = rand_vy
            }
        }

        // class Sound {
        //     constructor(src) {
        //         this.sound = document.createElement("audio");
        //         this.sound.src = src;
        //         this.sound.setAttribute("preload", "auto");
        //         this.sound.setAttribute("controls", "none");
        //         this.sound.style.display = "none";
        //         document.body.appendChild(this.sound);
        //     }
        //     play() {
        //         this.sound.play();
        //     }
        //     stop() {
        //         this.sound.pause();
        //     }
        // }

        let world = new World(world_cnv, sword_cnv)
        let fpsInterval, startTime, now, then, elapsed
        function animation_loop() {
            if (world.play) {
                window.requestAnimationFrame(animation_loop)
            }
            now = Date.now()
            elapsed = now - then
            if (elapsed > fpsInterval) {
                then = now - (elapsed % fpsInterval)
                world.update()
                world.draw()
            }
            // if (!world.start) world.start = Date.now()
            // world.current = Date.now()
        }
        function startAnimating(fps) {
            fpsInterval = 1000 / fps
            then = Date.now()
            startTime = then
            animation_loop()
        }
        startAnimating(60)
    </script>
</body>
</html>