<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Star Jumper</title>
    <style>
        body {
            color:white;
            background-color:black;
        }
        canvas {
            border: 1px solid white;
            background: linear-gradient(rgba(0, 0, 0, 0.5), rgba(0, 0, 0, 0.5)), url('whale_sulzenauer_big.jpg');
            background-size: 2400px 500px;
        }
    </style>
</head>
<body>
    <canvas id="cnv" width="1200" height="500"></canvas>
    <script>
        function random(lower, upper) {
            return lower + Math.random()*(upper-lower)
        }
        class Image {
            constructor(path, x, y) {
                this.element = document.createElement('img')
                this.element.src = path
                this.x = x
                this.y = y
              }
              draw(ctx) {
                    ctx.drawImage(this.element, this.x, this.y)
              }
        }

        // KEY TRACKER STUFF ==============================================
        class KeyTracker {
            constructor() {
                this.keys = [];
            }
            keyDown(key) {
                this.keys.push(key);
            }
            keyUp(key) {
                this.keys = this.keys.filter(function(e) {
                    return e !== key;
                });
            }
            isKeyDown(key) {
                return this.keys.indexOf(key) > -1;
            }
        }

        let key_tracker = new KeyTracker()
        document.addEventListener('keydown', (evt) => {
            key_tracker.keyDown(evt.key);
        });

        document.addEventListener('keyup', (evt) => {
            key_tracker.keyUp(evt.key);
        });

        // WORLD STUFF ==============================================
        class Rectangle {
            constructor(x, y, width, height, color) {
                this.x = x
                this.y = y
                this.width = width
                this.height = height
                this.color = color
            }
            update() {
                this.x += this.vx
                this.y += this.vy
            }
            draw(ctx) {
                ctx.fillStyle = this.color
                ctx.fillRect(this.x, this.y, this.width, this.height)
            }
            left() {
                return this.x
            }
            right() {
                return this.x + this.width
            }
            top() {
                return this.y
            }
            bottom() {
                return this.y + this.height
            }
        }

        class StarJumper extends Rectangle {
            constructor(x, y, width, height, color) {
                super(x, y, width, height, color);
                this.vy = 0
                this.vx = 0
                this.mx = 2
                this.star_count = 50
                this.star_cooldown = 0
                this.staa_ridin = false
                this.hurt_count = 0
                this.last_teleport = {}
                this.score = 0
                this.shot_speed = 5
                this.flip_count = 0
                this.flip_rotation = ''
                this.flip_type = ''
                this.facing = 'right'
            }
            draw(ctx) {
                ctx.save();
                let dir_switch
                if (this.facing === 'right') {
                    dir_switch = 1
                } else {
                    dir_switch = -1
                }
                let grd = ctx.createLinearGradient(0, this.height, this.width * dir_switch, -this.height/2)
                grd.addColorStop(0, this.color)
                grd.addColorStop(1, "white")
                ctx.fillStyle = grd
                ctx.translate(this.x + this.width/2, this.y + this.height/2);
                if (this.flip_rotation === 'clockwise') {
                    ctx.rotate(-Math.PI * this.flip_count / 30)
                } else {
                    ctx.rotate(Math.PI * this.flip_count / 30)
                }
                ctx.fillRect(-this.width/2, -this.height/2, this.height, this.width)
                if (this.flip_type === 'up') {
                    ctx.beginPath()
                    if (this.flip_count > 45) {
                        ctx.moveTo(0, 0)
                        ctx.lineTo((61 - this.flip_count) * dir_switch * 2, this.height * (61 - this.flip_count) / 15)
                        ctx.stroke()
                    } else if (this.flip_count > 0) {
                        ctx.moveTo(0, 0)
                        ctx.lineTo(this.flip_count * dir_switch, this.height * this.flip_count / 15)
                        ctx.stroke()
                    }
                }
                ctx.restore()
            }
            withinVert(r) {
                return this.top() < r.bottom()
                    && this.bottom() > r.top()
            }
            rubRight(r) {
                return this.right() < r.left()
                    && this.right() + this.mx >= r.left()
                    && this.withinVert(r)
            }
            rubLeft(r) {
                return this.left() > r.right()
                    && this.left() - this.mx <= r.right()
                    && this.withinVert(r)
            }
            landed(r) {
                return this.left() <= r.right()
                    && this.right() >= r.left()
                    && this.bottom() - this.vy <= r.top()
                    && this.bottom() + this.vy >= r.top()
            }
            hitHead(r) {
                return this.left() < r.right()
                    && this.right() > r.left()
                    && this.top() - this.vy >= r.bottom()
                    && this.top() + this.vy <= r.bottom()
            }
            grabStar() {
                this.color = 'red'
                this.star_count += 1
            }
            getShotVelocities(x_click, y_click) {
                let dx = x_click - this.x + this.width / 2
                let dy = y_click - this.y
                let return_vx = this.shot_speed * dx / (Math.abs(dx) + Math.abs(dy))
                let return_vy = this.shot_speed * dy / (Math.abs(dx) + Math.abs(dy))
                return {vx: return_vx, vy: return_vy}
            }
            getFlipAttack(x_click, y_click) {
                this.flip_count = 60
                let dx = x_click - this.x + this.width / 2
                let dy = y_click - this.y
                if (dx > 0 && dy > 0) {
                    this.flip_rotation = 'clockwise'
                    this.flip_type = 'down'
                    this.facing = 'right'
                    this.vy = -2
                } else if (dx > 0 & dy < 0) {
                    this.flip_rotation = 'counter'
                    this.flip_type = 'up'
                    this.facing = 'right'
                    this.vy = 0
                } else if (dx < 0 & dy > 0) {
                    this.flip_rotation = 'counter'
                    this.flip_type = 'down'
                    this.facing = 'left'
                    this.vy = -2
                } else {
                    this.flip_rotation = 'clockwise'
                    this.flip_type = 'up'
                    this.facing = 'left'
                    this.vy = 0
                }
            }
        }

        class StarShot extends Rectangle {
            constructor(x, y, width, height, color, vx, vy) {
                super(x, y, width, height, color);
                this.vx = vx
                this.vy = vy
                this.timer = 0
            }
        }

        class Portal {
            constructor(x, y, radius, color, vx=0, vy=0) {
                this.x = x
                this.y = y
                this.vx = vx
                this.vy = vy
                this.rad = radius
                this.color = color
                this.vib_count = 0
            }
            draw(ctx) {
                let grd = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, this.rad);
                grd.addColorStop(0, 'transparent');
                grd.addColorStop(1, this.color);
                ctx.beginPath()
                ctx.arc(this.x, this.y, this.rad, 0, 2 * Math.PI, false)
                ctx.fillStyle = grd;
                ctx.fill();
            }
            update(rad_multi) {
                this.rad = 10 + rad_multi * 20
                this.x += this.vx
                this.y += this.vy
            }
            checkCollideRec(rec) {
                let dx = this.x - (rec.x + rec.width / 2)
                let dy = this.y - (rec.y + rec.height / 2)
                let width = (this.rad*2 + rec.width) / 2
                let height = (this.rad*2 + rec.height) / 2
                if (Math.abs(dx) <= width && Math.abs(dy) <= height) {
                    return true
                }
                return false
            }
            checkCollideCir(cir) {
                let change_in_x = this.x - cir.x
                let change_in_y = this.y - cir.y
                let separation = Math.sqrt(change_in_x ** 2 + change_in_y ** 2)
                let combo_len = this.rad + cir.rad
                if (separation <= combo_len) {
                    // YOUR BALLS ARE TOUCHING, SEPARATE THEM
                    let diff = combo_len - separation
                    let nudge = diff / 2
                    let x_part_of_separation = (change_in_x / separation) ** 2
                    let y_part_of_separation = (change_in_y / separation) ** 2
                    let nudge_x = nudge * x_part_of_separation
                    let nudge_y = nudge * y_part_of_separation
                    // NUDGE YOUR BALLS BACK TO TOUCHING EDGES
                    this.x -= nudge_x
                    this.y -= nudge_y
                    cir.x += nudge_x
                    cir.y += nudge_y
                    // CALCULATE NEW VELOCITIES
                    let collision_angle = Math.atan2(cir.y - this.y, cir.x - this.x)
                    let vel_vect_len_i = this.getVelVectLen()
                    let vel_vect_len_j = cir.getVelVectLen()
                    if (vel_vect_len_i + vel_vect_len_j > 0) {
                        let direction_i = Math.atan2(this.vy, this.vx)
                        let direction_j = Math.atan2(cir.vy, cir.vx)
                        let vx_new_plane_i = vel_vect_len_i * Math.cos(direction_i - collision_angle)
                        let vy_new_plane_i = vel_vect_len_i * Math.sin(direction_i - collision_angle)
                        let vx_new_plane_j = vel_vect_len_j * Math.cos(direction_j - collision_angle)
                        let vy_new_plane_j = vel_vect_len_j * Math.sin(direction_j - collision_angle)
                        let vx_final_i = ((this.rad - cir.rad) * vx_new_plane_i + (cir.rad + cir.rad) * vx_new_plane_j) / (this.rad + cir.rad)
                        let vx_final_j = ((this.rad + this.rad) * vx_new_plane_i + (cir.rad - this.rad) * vx_new_plane_j) / (this.rad + cir.rad)
                        let vy_final_i = vy_new_plane_i
                        let vy_final_j = vy_new_plane_j
                        let cosAngle = Math.cos(collision_angle)
                        let sinAngle = Math.sin(collision_angle)
                        this.vx = cosAngle * vx_final_i - sinAngle * vy_final_i
                        this.vy = sinAngle * vx_final_i + cosAngle * vy_final_i
                        cir.vx = cosAngle * vx_final_j - sinAngle * vy_final_j
                        cir.vy = sinAngle * vx_final_j + cosAngle * vy_final_j
                        // MOVE IN NEW DIRECTION ONE TICK
                        this.x += this.vx
                        this.y += this.vy
                        cir.x += cir.vx
                        cir.y += cir.vy
                    }
                    return true
                }
                return false
            }
            getVelVectLen() {
                return Math.sqrt(this.vx ** 2 + this.vy ** 2)
            }
            setLeft(x) {
                this.x = x + this.rad
            }
            setRight(x) {
                this.x = x - this.rad
            }
            setTop(y) {
                this.y = y + this.rad
            }
            setBottom(y) {
                this.y = y - this.rad
            }
            Left() {
                return this.x
            }
            Right() {
                return this.x + this.rad
            }
            Top() {
                return this.y
            }
            Bottom() {
                return this.y + this.rad
            }
        }

        class GoldenStar extends Rectangle {
            constructor(x, y, width, height, color) {
                super(x, y, width, height, color);
                this.setRandomVelocities()
                this.last_teleport = {}
            }
            setRandomVelocities() {
                let rand_vx = random(.5, 1) * (Math.random < .5 ? -1 : 1)
                let rand_vy = random(.5, 1) * (Math.random < .5 ? -1 : 1)
                this.vx = rand_vx
                this.vy = rand_vy
            }
        }

        class World {
            constructor(width, height, cnv) {
                this.cnv = cnv
                this.cnv_rect = this.cnv.getBoundingClientRect()
                this.ctx = this.cnv.getContext('2d')
                this.width = width
                this.height = height
                this.star_size = 4
                this.player_on_platform = true
                this.ground_height = 20
                ////// PLATFORMS ///////
                this.platforms = []
                this.ground = new Rectangle(0, this.height - this.ground_height,
                                            this.width, this.ground_height, 'green')
                this.platforms.push(this.ground)
                ////// StarJumper ///////
                let player_size = 20
                this.player = new StarJumper(cnv.width/2-player_size/2,
                                            cnv.height-this.ground_height-player_size,
                                            player_size, player_size, 'red')
                ////// GoldenStar ///////
                this.golden_star = new GoldenStar(random(100, this.width - 100),
                                                  random(0, this.height * .8),
                                                  this.star_size, this.star_size, 'yellow')
                ////// Stars ///////
                for (let i=0; i<100; i++) {
                      let x = random(10, this.width-10)
                      let y = random(10, this.height-this.ground_height-this.star_size-10)
                      let star = new Rectangle(x, y, this.star_size, this.star_size, 'white')
                      this.platforms.push(star)
                }
                ////// Portals ///////
                this.circles = []
                for (let i=0; i<10; i++) {
                    let x, y
                    let radius = 10 + Math.random() * 10;
                    let color = `hsl(${i*36}, 100%, 50%)`

                    x = random(radius, width - radius)
                    y = random(radius, height * .8)
                    let p1 = new Portal(x, y, radius, color, Math.random()-.5, Math.random()-.5)

                    x = random(radius, width - radius)
                    y = random(radius, height * .8)
                    let p2 = new Portal(x, y, radius, color, Math.random()-.5, Math.random()-.5)

                    this.circles.push(p1)
                    this.circles[this.circles.length - 1].portal_pair = p2
                    this.circles.push(p2)
                    this.circles[this.circles.length - 1].portal_pair = p1
                }
                ///// LEFT CLICK - SHOOT STAR ///////
                this.shooting_stars = []
                this.cnv.onclick = (e) => {
                    if (this.player.flip_count <= 0) {
                        let trans_x = this.getTransX()
                        let shot_vel = this.player.getShotVelocities(
                            e.clientX - this.cnv_rect.left - trans_x - this.player.width,
                            e.clientY - this.cnv_rect.top)
                        let shot = new StarShot(this.player.x + this.player.width / 2, this.player.y,
                            this.star_size, this.star_size, 'red', shot_vel.vx, shot_vel.vy)
                        this.shooting_stars.push(shot)
                    }
                }
                ///// RIGHT CLICK - SWORD SWIPE ///////
                this.cnv.oncontextmenu = (e) => {
                    if (this.player.flip_count <= 0 && !this.player.staa_ridin) {
                        let trans_x = this.getTransX()
                        this.player.getFlipAttack(e.clientX - this.cnv_rect.left - trans_x - this.player.width,
                            e.clientY - this.cnv_rect.top)
                    }
                    return false
                }
            }

            getTransX() {
                // trans_x is how far left to shift to get the
                // right part of the world into view
                let trans_x = -this.player.x + this.cnv.width/2
                // if the adjustment would go past the end of the world...
                if (trans_x > 0) {
                    return  0
                } else if (trans_x < -this.width + this.cnv.width) {
                    return -this.width + this.cnv.width
                }
                return trans_x
            }

            draw() {
                this.ctx.clearRect(0, 0, this.cnv.width, this.cnv.height)
                this.ctx.lineWidth = 3
                let trans_x = this.getTransX()
                this.ctx.translate(trans_x, 0)
                for (let i=0; i<this.platforms.length; i++) {
                    this.platforms[i].draw(this.ctx)
                }
                for (let i=0; i<this.circles.length; i++) {
                    if (this.circles[i].vib_count > 0) {
                        if (this.circles[i].vib_count % 4 < 2) {
                            this.circles[i].rad += 2
                            this.circles[i].draw(this.ctx)
                            this.circles[i].rad -= 2
                        } else {
                            this.circles[i].draw(this.ctx)
                        }
                    } else {
                        this.circles[i].draw(this.ctx)
                    }
                }
                for (let i=0; i<this.shooting_stars.length; i++) {
                    this.shooting_stars[i].draw(this.ctx)
                }
                this.player.draw(this.ctx)
                this.golden_star.draw(this.ctx)
                this.ctx.resetTransform()
                this.ctx.fillStyle = "white"
                this.ctx.font = "30px Arial"
                this.ctx.fillText('Star Pouch: ' + this.player.star_count, 10, 30)
                this.ctx.fillText('Score: ' + this.player.score, this.cnv.width - 130, 30)
                this.cnv.style.backgroundPositionX = trans_x + 'px'

                let status_bar_left = this.cnv.width * .25
                let status_bar_width = this.cnv.width * .5
                let player_position_in_world = (this.player.x + this.player.width / 2) / this.width
                let player_status_bar_position = status_bar_width * player_position_in_world + status_bar_left
                let golden_star_position_in_world = (this.golden_star.x + this.golden_star.width / 2) / this.width
                let golden_star_status_bar_position = status_bar_width * golden_star_position_in_world + status_bar_left

                this.ctx.lineWidth = 2
                this.ctx.beginPath()
                this.ctx.moveTo(status_bar_left, 20)
                this.ctx.lineTo(status_bar_left + status_bar_width, 20)
                this.ctx.strokeStyle = 'white'
                this.ctx.stroke()

                this.ctx.lineWidth = 5
                this.ctx.beginPath()
                this.ctx.moveTo(player_status_bar_position, 10)
                this.ctx.lineTo(player_status_bar_position, 30)
                this.ctx.strokeStyle = 'red'
                this.ctx.stroke()

                this.ctx.beginPath()
                this.ctx.moveTo(golden_star_status_bar_position, 10)
                this.ctx.lineTo(golden_star_status_bar_position, 30)
                this.ctx.strokeStyle = 'yellow'
                this.ctx.stroke()
            }

            update() {
                for (let i = 0; i < this.circles.length; i++) {
                    ///// MOVE PORTAL, SIZE ACCORDING TO PORTAL PAIR /////
                    let portal_pair_position = Math.abs(this.circles[i].portal_pair.x - this.golden_star.x) / this.width
                    this.circles[i].update(portal_pair_position)
                    ///// BOUNCE PORTALS OFF SIDES & GROUND //////
                    if (this.circles[i].x + this.circles[i].rad > this.width) {
                        this.circles[i].setRight(this.width)
                        this.circles[i].vx *= -1
                        this.circles[i].x += this.circles[i].vx
                    } else if (this.circles[i].x - this.circles[i].rad < 0) {
                        this.circles[i].setLeft(0)
                        this.circles[i].vx *= -1
                        this.circles[i].x += this.circles[i].vx
                    } else if (this.circles[i].y + this.circles[i].rad > this.height - this.ground_height) {
                        this.circles[i].setBottom(this.height - this.ground_height)
                        this.circles[i].vy *= -1
                        this.circles[i].y += this.circles[i].vy
                    } else if (this.circles[i].y - this.circles[i].rad < 0) {
                        this.circles[i].setTop(0)
                        this.circles[i].vy *= -1
                        this.circles[i].y += this.circles[i].vy
                    }
                    ///// CHECK TO SEE IF PORTAL HIT ANOTHER PORTAL //////
                    for (let j = 0; j < this.circles.length; ++j) {
                        if (i === j) continue
                        let result = this.circles[i].checkCollideCir(this.circles[j])
                        if (result) {
                            this.circles[i].vib_count = 60
                            this.circles[i].vy > 0 ? this.circles[i].vy += .002 : this.circles[i].vy -= .002
                            this.circles[i].vx > 0 ? this.circles[i].vx += .002 : this.circles[i].vx -= .002
                            this.circles[j].vib_count = 60
                            this.circles[j].vy > 0 ? this.circles[j].vy += .002 : this.circles[j].vy -= .002
                            this.circles[j].vx > 0 ? this.circles[j].vx += .002 : this.circles[j].vx -= .002
                        }
                    }
                    ///// SEE IF PORTAL HITS PLAYER, EXCEPT LAST PORTAL EXITED //////
                    if (this.circles[i] != this.player.last_teleport) {
                        let hit_player = this.circles[i].checkCollideRec(this.player)
                        if (hit_player) {
                            this.player.vy = 0
                            this.player.last_teleport = this.circles[i].portal_pair
                            this.player.x = this.circles[i].portal_pair.x
                            this.player.y = this.circles[i].portal_pair.y
                        }
                    }
                    ///// SEE IF PORTAL HITS GOLDEN STAR, EXCEPT LAST PORTAL EXITED //////
                    if (this.circles[i] != this.golden_star.last_teleport) {
                        let hit_golden_star = this.circles[i].checkCollideRec(this.golden_star)
                        if (hit_golden_star) {
                            this.golden_star.last_teleport = this.circles[i].portal_pair
                            this.golden_star.x = this.circles[i].portal_pair.x
                            this.golden_star.y = this.circles[i].portal_pair.y
                            if (this.circles[i].portal_pair.vx > 0) {
                                this.golden_star.vx = -Math.abs(this.golden_star.vx)
                            } else {
                                this.golden_star.vx = Math.abs(this.golden_star.vx)
                            }
                            if (this.circles[i].portal_pair.vy > 0) {
                                this.golden_star.vy = -Math.abs(this.golden_star.vy)
                            } else {
                                this.golden_star.vy = Math.abs(this.golden_star.vy)
                            }
                        }
                    }
                    ///// REDUCE VIBRATION COUNT //////
                    this.circles[i].vib_count -= 1
                }
                ///// BOUNCE GOLDEN STAR //////
                let is_ob_right = this.golden_star.x + this.golden_star.width > this.width
                let is_ob_left = this.golden_star.x < 0
                if (is_ob_right || is_ob_left) this.golden_star.vx *= -1
                let is_ob_top = this.golden_star.y > this.height - this.ground.height - this.star_size
                let is_ob_bottom = this.golden_star.y < 0
                if (is_ob_top || is_ob_bottom) this.golden_star.vy *= -1
                ///// JUMP IF ON PLATFORM ////////
                if ((key_tracker.isKeyDown('ArrowUp') || key_tracker.isKeyDown('w')) && this.player_on_platform) {
                    this.player.vy = -6
                    this.player.y -= 0.3
                    this.player.staa_ridin = false
                }
                ///// DEFAULT ASSUMPTIONS, RESET, INCREMENT, ETC //////
                this.player_on_platform = false
                this.player.star_cooldown -= 1
                this.player.hurt_count -= 1
                let rubbing = false
                ///// GO RIGHT OR LEFT /////
                if (!this.player.staa_ridin) {
                    if (key_tracker.isKeyDown('ArrowLeft')|| key_tracker.isKeyDown('a')) {
                        if (this.player.flip_count <= 0) {
                            this.player.facing = 'left'
                            ///// CHECK LEFT BUMP /////
                            for (let i = 0; i < this.platforms.length; i++) {
                                if (this.player.rubLeft(this.platforms[i])) {
                                    rubbing = true
                                    break
                                }
                            }
                        }
                        if (!rubbing) this.player.x -= this.player.mx
                        ///// TOO FAR LEFT /////
                        if (this.player.x < 0) this.player.x = 0
                    } else if (key_tracker.isKeyDown('ArrowRight') || key_tracker.isKeyDown('d')) {
                        if (this.player.flip_count <= 0) {
                            this.player.facing = 'right'
                            ///// CHECK RIGHT BUMP /////
                            for (let i = 0; i < this.platforms.length; i++) {
                                if (this.player.rubRight(this.platforms[i])) {
                                    rubbing = true
                                    break
                                }
                            }
                        }
                        if (!rubbing) this.player.x += this.player.mx
                        ///// TOO FAR RIGHT /////
                        if (this.player.x + this.player.width > world.width) {
                            this.player.x = world.width - this.player.width
                        }
                    }
                }
                ///// GOLDEN STAR /////
                this.golden_star.update()
                ///// IF RIDING ON GOLDEN STAR /////
                if (this.player.staa_ridin) {
                    this.player_on_platform = true
                    this.player.x = this.golden_star.x - (this.player.width - this.star_size) / 2
                    this.player.y = this.golden_star.y - this.player.height
                    ///// PICK UP GOLDEN STAR  /////
                    if (key_tracker.isKeyDown('ArrowDown') || key_tracker.isKeyDown('s')) {
                        this.player.staa_ridin = false
                        this.player_on_platform = false
                        this.player.star_cooldown = 10
                        this.player.score += 1
                        this.golden_star.x = random(0, this.width - this.star_size)
                        this.golden_star.y = random(0, this.height - this.star_size - this.ground_height)
                        this.golden_star.setRandomVelocities()
                    }
                ///// IF YOU LAND ON THE GOLDEN STAR /////
                } else if (this.player.landed(this.golden_star) && !this.player.staa_ridin) {
                    this.player_on_platform = true
                    this.player.staa_ridin = true
                    this.player.flip_count = 0
                ///// IF YOU ARE FLIPPING, UP OR DOWN /////
                } else if (this.player.flip_count > 0) {
                    if (this.player.flip_type === 'up') {
                        this.player.vy -= .05
                    } else {
                        this.player.vy += 1
                    }
                    this.player.y += this.player.vy
                    if (this.player.y + this.player.height + this.ground.height >= this.height) {
                        this.player.y = this.height - this.player.height - this.ground.height
                        this.player.flip_count = 0
                    } else {
                        this.player.flip_count -= 1
                    }
                ///// OTHERWISE CHECK NORMAL HITS /////
                } else {
                    for (let i = 0; i < this.platforms.length; i++) {
                        ///// LANDED ON STAR OR GROUND /////
                        if (this.player.landed(this.platforms[i])) {
                            this.player.color = 'red'
                            this.player.y = this.platforms[i].top() - this.player.height
                            this.player.vy = 0
                            this.player_on_platform = true
                            ///// DOWN KEY = PICK UP STAR /////
                            if ((key_tracker.isKeyDown('ArrowDown') || key_tracker.isKeyDown('s'))
                                && this.platforms[i] != this.ground && this.player.star_cooldown < 0) {
                                    this.player.star_cooldown = 10
                                    this.player.grabStar()
                                    this.platforms.splice(i, 1)
                            }
                            break
                        ///// CHECK HEAD BUMP /////
                        } else if (this.player.hitHead(this.platforms[i]) && this.player.vy < 0
                            && this.platforms[i] != this.ground && this.player.flip_count <= 0) {
                                this.player.y = this.platforms[i].bottom() + .001
                                this.player.vy = -.015
                                break
                        }
                    }
                }
                ///// UPDATE STAR SHOTS /////
                for (let i=0; i<this.shooting_stars.length; i++) {
                    ///// UPDATE & BOUNCE SHOTS IN PLAY /////
                    if (this.shooting_stars[i].timer === 0) {
                        this.shooting_stars[i].update()
                        if (this.shooting_stars[i].x > this.width - this.star_size) {
                            this.shooting_stars[i].vx *= -1
                            this.shooting_stars[i].x = this.width - this.star_size - this.shooting_stars[i].vx
                        } else if (this.shooting_stars[i].x < 0) {
                            this.shooting_stars[i].vx *= -1
                            this.shooting_stars[i].x = this.shooting_stars[i].vx
                        } else if (this.shooting_stars[i].y + this.star_size > this.height - this.ground_height) {
                            this.shooting_stars[i].y = this.height + this.star_size + this.ground_height
                            this.shooting_stars[i].timer = 30
                        } else if (this.shooting_stars[i].y < 0) {
                            this.shooting_stars[i].vy *= -1
                            this.shooting_stars[i].y += this.shooting_stars[i].vy
                        }
                    ///// REMOVE INFLATED SHOTS THAT HAVE REACHED 1 /////
                    } else if (this.shooting_stars[i].timer === 1) {
                        this.shooting_stars.splice(i, 1)
                    ///// INFLATE STARS THAT HAVE HIT GROUND /////
                    } else {
                        this.shooting_stars[i].timer -= 1
                        this.shooting_stars[i].height += .6
                        this.shooting_stars[i].width += .6
                        this.shooting_stars[i].y = this.height - this.ground_height - this.shooting_stars[i].height
                        this.shooting_stars[i].x -= .3
                    }
                }
                ///// MID AIR SCENARIOS - NOT ON A PLATFORM OR GOLDEN STAR, NOT FLIPPING /////
                if (!this.player_on_platform && !this.player.staa_ridin && this.player.flip_count <= 0) {
                    this.player.vy += 0.2
                    this.player.y += this.player.vy
                    ///// CHECK GROUND BOUNCE /////
                    if (this.player.y + this.player.height + this.ground.height >= this.height) {
                        this.player.y = this.height - this.player.height - this.ground.height
                    }
                    ///// HIT DOWN KEY, S, OR SPACE TO ADD STAR UNDER STAR JUMPER /////
                    if ((key_tracker.isKeyDown(' ') || key_tracker.isKeyDown('s'))
                        && this.player.star_count > 0 && this.player.star_cooldown < 0) {
                            let new_star_x = this.player.x + (this.player.height - this.star_size) / 2
                            let new_star_y = this.player.y + this.player.height
                            let star = new Rectangle(new_star_x, new_star_y, this.star_size, this.star_size, 'white')
                            this.platforms.push(star)
                            this.player.vy = 0
                            this.player.star_cooldown = 10
                            this.player_on_platform = true
                            this.player.star_count -= 1
                    }
                }
            }
        }

        let cnv = document.querySelector('#cnv')
        let world = new World(cnv.width * 2, cnv.height, cnv)

        function animation_loop() {
            window.requestAnimationFrame(animation_loop)
            world.update()
            world.draw()
        }
        window.requestAnimationFrame(animation_loop)
    </script>
</body>
</html>