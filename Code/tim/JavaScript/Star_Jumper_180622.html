<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>

</body>
</html><!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Star Jumper</title>
    <link href="https://fonts.googleapis.com/css?family=Open+Sans" rel="stylesheet">
    <style>
        body {
            color: white;
            background-color: black;
            font-family: 'Open Sans', sans-serif;
        }
        #world_cnv {
            background-image: url('whale_sulzenauer_big.jpg');
        }
        canvas {
            border: 1px solid white;
            background-size: 2400px 480px;
            position: absolute;
            top: 10px;
            left: 10px;

        }
        button {
            position: absolute;
            top: 520px;
            border-radius: 4px;
            z-index: 10;
        }
        #modal_background {
            display: none; /* Hidden by default */
            position: fixed; /* Stay in place */
            z-index: 11; /* Sit on top */
            left: 0;
            top: 0;
            width: 100%; /* Full width */
            height: 100%; /* Full height */
            overflow: auto; /* Enable scroll if needed */
            background-color: rgba(0,0,0,0.4); /* Black w/ opacity */
        }
        #instruction_modal_div {
            position: fixed;
            z-index: 12;
            margin-left: -40%;
            transition: margin-left 1s;
            height: 300px;
            width: 500px;
            top: 50px;
            border: 3px solid deepskyblue;
            background-color: white;
            border-radius: 4px;
            overflow: hidden;
        }
        #instruction_options_div {
            display: flex;
            text-align: center;
        }
        .option {
            flex: 1;
            margin: 5px;
            border-radius: 4px;
            border: 3px solid black;
            background-color: deepskyblue;
            font-size: 2em;
            font-weight: bolder;
            color: black;
        }
        #rules_option {
            background-color: darkorchid;
        }
        .option:hover {
            background: mediumblue !important;
            cursor: pointer;
        }
        .instruction_border {
            position: absolute;
            transition: margin-left 1s;
            width: 500px;
        }
        .instruction {
            height: 220px;
            margin: 5px;
            margin-top: 0;
            padding: 5px;
            border-radius: 4px;
            border: 3px solid black;
            color: black;
        }
        #instruction_div {
            display: flex;
        }
        #rules_border {
            margin-left: 0%;
        }
        #controls_border {
            margin-left: 100%;
        }
        #other_border {
            margin-left: 200%;
        }
        #instruction_div > button {
            position: absolute;
            left: 450px;
            top: 268px;
        }
    </style>
</head>
<body>
    <canvas id="world_cnv" width="1200" height="500"></canvas>
    <canvas id="sword_cnv" width="1200" height="500"></canvas>
    <!--<canvas id="player_shots_cnv" width="1200" height="500"></canvas>-->
    <!--<canvas id="enemy_attack_cnv" width="1200" height="500"></canvas>-->
    <div id="modal_background"></div>
    <div id="instruction_modal_div">
        <div id="instruction_options_div">
            <div id="rules_option" class="option">Rules</div>
            <div id="controls_option" class="option">Controls</div>
            <div id="other_option" class="option">Other</div>
        </div>
        <div id="instruction_div">
            <div id="rules_border" class="instruction_border">
                <div id="rules_div" class="instruction">
                    The object of Star Jumper is (to be determined)...
                </div>
            </div>
            <div id="controls_border" class="instruction_border">
                <div id="controls_div" class="instruction">
                    "A" / LEFT : go left<br>
                    "D" / RIGHT : go right<br>
                    "W" / UP : jump<br>
                    "S" / SPACE : pick up & place star<br>
                    LEFT CLICK : shoot star<br>
                    RIGHT CLICK (ABOVE) : flip up attack<br>
                    RIGHT CLICK (BELOW) : flip down attack
                </div>
            </div>
            <div id="other_border" class="instruction_border">
                <div id="other_div" class="instruction">
                    Other Stuff
                </div>
            </div>
            <button id="hide_modal_bt">Exit</button>
        </div>
    </div><br>
    <button id="show_modal_bt">Rules</button>
    <script>
        let world_cnv = document.querySelector('#world_cnv')
        let sword_cnv = document.querySelector('#sword_cnv')
        // let player_shots_cnv = document.querySelector('#player_shots_cnv')
        // let enemy_attack_cnv = document.querySelector('#enemy_attack_cnv')
        let show_modal_bt = document.querySelector('#show_modal_bt')
        let modal_background = document.querySelector('#modal_background')
        let instruction_modal_div = document.querySelector('#instruction_modal_div')
        let hide_modal_bt = document.querySelector('#hide_modal_bt')
        let rules_option = document.querySelector('#rules_option')
        let controls_option = document.querySelector('#controls_option')
        let other_option = document.querySelector('#other_option')
        let rules_border = document.querySelector('#rules_border')
        let controls_border = document.querySelector('#controls_border')
        let other_border = document.querySelector('#other_border')

        show_modal_bt.onclick = () => {
            modal_background.style.display = 'block'
            instruction_modal_div.style.transition = 'margin-left 1s'
            instruction_modal_div.style.marginLeft = '20%'
            world.play = false
        }
        hide_modal_bt.onclick = () => {
            rules_border.style.marginLeft = '0%'
            controls_border.style.marginLeft = '100%'
            other_border.style.marginLeft = '200%'
            instruction_modal_div.style.transition = 'none'
            instruction_modal_div.style.marginLeft = '-50%'
            modal_background.style.display = 'none'
            world.play = true
            window.requestAnimationFrame(animation_loop)
        }
        rules_option.onclick = () => {
            rules_option.style.backgroundColor = 'darkorchid'
            rules_border.style.marginLeft = '0%'
            controls_option.style.backgroundColor = 'deepskyblue'
            controls_border.style.marginLeft = '100%'
            other_option.style.backgroundColor = 'deepskyblue'
            other_border.style.marginLeft = '200%'
        }
        controls_option.onclick = () => {
            rules_option.style.backgroundColor = 'deepskyblue'
            rules_border.style.marginLeft = '-100%'
            controls_option.style.backgroundColor = 'darkorchid'
            controls_border.style.marginLeft = '0%'
            other_option.style.backgroundColor = 'deepskyblue'
            other_border.style.marginLeft = '100%'
        }
        other_option.onclick = () => {
            rules_option.style.backgroundColor = 'deepskyblue'
            rules_border.style.marginLeft = '-200%'
            controls_option.style.backgroundColor = 'deepskyblue'
            controls_border.style.marginLeft = '-100%'
            other_option.style.backgroundColor = 'darkorchid'
            other_border.style.marginLeft = '0%'
        }
        function random(lower, upper) {
            return lower + Math.random()*(upper-lower)
        }
    </script>
    <script>
        class Image {
            constructor(path, x, y) {
                this.element = document.createElement('img')
                this.element.src = path
                this.x = x
                this.y = y
              }
              draw(world_ctx) {
                    world_ctx.drawImage(this.element, this.x, this.y)
              }
        }

        // KEY TRACKER STUFF ==============================================
        class KeyTracker {
            constructor() {
                this.keys = [];
            }
            keyDown(key) {
                this.keys.push(key);
            }
            keyUp(key) {
                this.keys = this.keys.filter(function(e) {
                    return e !== key;
                });
            }
            isKeyDown(key) {
                return this.keys.indexOf(key) > -1;
            }
        }

        let key_tracker = new KeyTracker()
        document.addEventListener('keydown', (evt) => {
            key_tracker.keyDown(evt.key);
        });

        document.addEventListener('keyup', (evt) => {
            key_tracker.keyUp(evt.key);
        });

        // WORLD STUFF ==============================================

        function checkAttackOnCTX(x, y, width, height, ctx) {
            ///// TEST 9 POINTS ON RECTANGLE, THAT'S GOOD ENOUGH /////
            // let rect_data = sword_ctx.getImageData(x, y, width, height)   <--- wasn't working
            if (width + height < 20) {
                let px_data = ctx.getImageData(x+width/2, y+height/2, 1, 1)
                if (px_data.data[3] > 0) return true
            } else {
                for (let i=0; i<3; i++) {
                    for (let j=0; j<3; j++) {
                        let px_data = ctx.getImageData(x + i*width/2, y + j*height/2, 1, 1)
                        if (px_data.data[3] > 0) return true
                    }
                }
            }
            return false
        }

        function getShotVelocities(x_destination, y_destination, x_origin, y_origin, speed) {
            let dx = x_destination - x_origin
            let dy = y_destination - y_origin
            let return_vx = speed * dx / (Math.abs(dx) + Math.abs(dy))
            let return_vy = speed * dy / (Math.abs(dx) + Math.abs(dy))
            return {vx: return_vx, vy: return_vy}
        }

        function getClosestTarget(x, y, enemies) {
            let closest_enemy
            let smallest_separation2 = 999999
            for (let i=0; i<enemies.length; i++) {
                let change_in_x = x - enemies[i].x + enemies[i].width/2
                let change_in_y = y - enemies[i].y + enemies[i].height/2
                let separation2 = change_in_x*change_in_x + change_in_y * change_in_y
                if (separation2 < smallest_separation2) {
                    smallest_separation2 = separation2
                    closest_enemy = enemies[i]
                }
            }
            return closest_enemy
        }

        class Rectangle {
            constructor(x, y, width, height, color) {
                this.x = x
                this.y = y
                this.width = width
                this.height = height
                this.color = color
                this.rgb = {r:255, g:0, b:0}
            }
            update() {
                this.x += this.vx
                this.y += this.vy
            }
            draw(ctx) {
                ctx.fillStyle = this.color
                ctx.fillRect(this.x, this.y, this.width, this.height)
            }
            left() {
                return this.x
            }
            right() {
                return this.x + this.width
            }
            top() {
                return this.y
            }
            bottom() {
                return this.y + this.height
            }
            center() {
                return [this.x + this.width/2, this.y + this.height/2]
            }
            checkCollideRec(rec) {
                let dx = (this.x + this.width/2) - (rec.x + rec.width/2)
                let dy = (this.y + this.height/2) - (rec.y + rec.height/2)
                let x_width = (this.width + rec.width) / 2
                let x_height = (this.height + rec.height) / 2
                return Math.abs(dx) <= x_width && Math.abs(dy) <= x_height
            }
        }

        class StarJumper extends Rectangle {
            constructor(x, y, width, height, color) {
                super(x, y, width, height, color);
                this.vy = 0
                this.vx = 0
                this.mx = 2
                this.star_count = 50
                this.star_cooldown = 0
                this.staa_ridin = false
                this.hurt_count = 0
                this.last_teleport = {}
                this.score = 0
                this.base_energy = 100
                this.energy = 100
                this.shot_speed = 6
                this.shots = []
                this.sword_tip = {x:0, y:0}
                this.sword_trail = []
                this.flip_duration = 60
                this.flip_count = 0
                this.flip_rotation = ''
                this.flip_type = ''
                this.facing = 1 // right
            }
            draw(world_ctx, sword_ctx) {
                world_ctx.save();
                let grd = world_ctx.createLinearGradient(0, 0, this.width * this.facing , -this.height/4)
                grd.addColorStop(0, this.color)
                grd.addColorStop(1, "white")
                world_ctx.fillStyle = grd
                world_ctx.translate(this.x + this.width / 2, this.y + this.height / 2)
                if (this.flip_count < 31) {
                    if (this.flip_rotation === 'clockwise') {
                        world_ctx.rotate(-Math.PI * this.flip_count / 15)
                    } else {
                        world_ctx.rotate(Math.PI * this.flip_count / 15)
                    }
                }
                world_ctx.fillRect(-this.width / 2, -this.height / 2, this.width, this.height)
                world_ctx.restore()
                ///// FLIPPING === SWORD SEQUENCE /////
                if (this.flip_count > 0) {
                    let x_cen = this.x + this.width / 2
                    let y_cen = this.y + this.height / 2
                    ///// FLIP SEQUENCE IS 60 FRAMES, SWORD STARTS AFTER FRAME 10 /////
                    if (this.flip_count < 50) {
                        ///// UP SEQUENCE - GET SWORD TIPS/////
                        if (this.flip_type === 'up') {
                            if (this.flip_count > 40) {
                                this.sword_tip.x = x_cen + (50 - this.flip_count) * 5 * this.facing // full length = 50
                                this.sword_tip.y = y_cen
                            } else if (this.flip_count > 10) {
                                let dx = Math.cos((41 - this.flip_count) / 40 * Math.PI) * 50
                                let dy = Math.sin((41 - this.flip_count) / 40 * Math.PI) * 50
                                this.sword_tip.x = x_cen + dx * this.facing
                                this.sword_tip.y = y_cen - dy
                            } else {
                                let dx = Math.cos((41 - this.flip_count) / 40 * Math.PI) * 5 * this.flip_count
                                let dy = Math.sin((41 - this.flip_count) / 40 * Math.PI) * 5 * this.flip_count
                                this.sword_tip.x = x_cen + dx * this.facing
                                this.sword_tip.y = y_cen - dy
                            }
                        ///// DOWN SEQUENCE - GET SWORD TIPS /////
                        } else {
                            this.sword_tip.x = x_cen
                            this.sword_tip.y = y_cen
                            if (this.flip_count > 40) {
                                let dx = Math.cos((this.flip_count - 40) * .075 * Math.PI) * 50
                                let dy = Math.sin((this.flip_count - 40) * .075 * Math.PI) * 50
                                this.sword_tip.x = x_cen + dx * this.facing
                                this.sword_tip.y = y_cen - dy
                            } else {
                                this.sword_tip.x = x_cen + 50 * this.facing
                                this.sword_tip.y = y_cen + (41 - this.flip_count) / 2
                            }
                        }
                        this.sword_trail[this.sword_trail.length - 1].push({
                            life: 60,
                            x_cen: x_cen,
                            y_cen: y_cen,
                            x_tip: this.sword_tip.x,
                            y_tip: this.sword_tip.y
                        })
                        world_ctx.beginPath()
                        world_ctx.moveTo(x_cen, y_cen)
                        world_ctx.lineTo(this.sword_tip.x, this.sword_tip.y)
                        world_ctx.stroke()
                    }
                }
                if (this.sword_trail.length > 0) {
                    if (this.sword_trail[0].length === 0 && this.sword_trail.length>1) {
                        this.sword_trail.splice(0, 1)
                    }
                    sword_ctx.fillStyle = this.color
                    for (let k=0; k<this.sword_trail.length; k++) {
                        let poly_path = {tip: [], cen: []}
                        for (let i = 0; i < this.sword_trail[k].length; i++) {
                            this.sword_trail[k][i].life -= 1
                            if (this.sword_trail[k][i].life === 0) {
                                this.sword_trail[k].splice(i, 1)
                                continue
                            }
                            poly_path.tip.push({x: this.sword_trail[k][i].x_tip, y: this.sword_trail[k][i].y_tip})
                            poly_path.cen.push({x: this.sword_trail[k][i].x_cen, y: this.sword_trail[k][i].y_cen})
                        }
                        if (poly_path.tip.length > 0) {
                            sword_ctx.beginPath()
                            sword_ctx.moveTo(poly_path.tip[0].x, poly_path.tip[0].y)
                            for (let i = 1; i < poly_path.tip.length; i++) {
                                sword_ctx.lineTo(poly_path.tip[i].x, poly_path.tip[i].y)
                            }
                            for (let i = poly_path.cen.length - 1; i > 0; i--) {
                                sword_ctx.lineTo(poly_path.cen[i].x, poly_path.cen[i].y)
                            }
                            sword_ctx.strokeStyle = "rgba(" + this.rgb["r"] + "," + this.rgb["g"] + "," + this.rgb["b"] +
                                "," + poly_path.tip.length / 60 + ")"
                            sword_ctx.closePath()
                            sword_ctx.stroke()
                            sword_ctx.fillStyle = sword_ctx.strokeStyle
                            sword_ctx.fillColor = this.color
                            sword_ctx.fill()
                        }
                    }
                }
            }
            withinVert(r) {
                return this.top() < r.bottom()
                    && this.bottom() > r.top()
            }
            rubRight(r) {
                return this.right() < r.left()
                    && this.right() + this.mx >= r.left()
                    && this.withinVert(r)
            }
            rubLeft(r) {
                return this.left() > r.right()
                    && this.left() - this.mx <= r.right()
                    && this.withinVert(r)
            }
            landed(r) {
                return this.left() <= r.right()
                    && this.right() >= r.left()
                    && this.bottom() - this.vy <= r.top()
                    && this.bottom() + this.vy >= r.top()
            }
            hitHead(r) {
                return this.left() < r.right()
                    && this.right() > r.left()
                    && this.top() - this.vy >= r.bottom()
                    && this.top() + this.vy <= r.bottom()
            }
            grabStar() {
                this.star_count += 1
                this.energy += 20
                if (this.energy > 100) this.energy = 100
            }
            getFlipAttack(x_click, y_click) {
                let dx = x_click - this.x + this.width / 2
                let dy = y_click - this.y
                if (dx > 0 && dy > 0 && this.energy >= 25) {
                    this.flip_count = this.flip_duration
                    this.flip_rotation = 'clockwise'
                    this.flip_type = 'down'
                    this.facing = 1 // right
                    this.vy = -2
                    this.energy -= 25
                    return true
                } else if (dx > 0 & dy < 0 && this.energy >= 25) {
                    this.flip_count = this.flip_duration
                    this.flip_rotation = 'counter'
                    this.flip_type = 'up'
                    this.facing = 1 // right
                    this.vy = -.6
                    this.energy -= 25
                    return true
                } else if (dx < 0 & dy > 0 && this.energy >= 25) {
                    this.flip_count = this.flip_duration
                    this.flip_rotation = 'counter'
                    this.flip_type = 'down'
                    this.facing = -1 // left
                    this.vy = -2
                    this.energy -= 25
                    return true
                } else if (this.energy >= 40) {
                    this.flip_count = this.flip_duration
                    this.flip_rotation = 'clockwise'
                    this.flip_type = 'up'
                    this.facing = -1 // left
                    this.vy = -.6
                    this.energy -= 25
                    return true
                }
            }
        }

        class World {
            constructor(world_cnv, sword_cnv) {
                this.play = true
                this.world_cnv = world_cnv
                this.sword_cnv = sword_cnv
                // this.player_shots_cnv = player_shots_cnv
                // this.enemy_attack_cnv = enemy_attack_cnv
                this.world_ctx = world_cnv.getContext('2d')
                this.sword_ctx = sword_cnv.getContext('2d')
                // this.player_shots_ctx = player_shots_cnv.getContext('2d')
                // this.enemy_attack_ctx = enemy_attack_cnv.getContext('2d')
                this.cnv_rect = sword_cnv.getBoundingClientRect()
                this.width = sword_cnv.width * 2
                this.height = sword_cnv.height
                this.star_size = 3
                this.player_on_platform = true
                this.ground_height = 20
                this.dv = .03
                this.total_velocity = 0
                this.max_velocity = 40
                ////// SOUNDS ///////
                // this.sounds = []
                // let my_sounds = [
                //     'Neck Breaking-SoundBible.com-933536431.mp3',
                //     'Punch_HD-Mark_DiAngelo-1718986183.mp3',
                //     'Super Punch MMA-SoundBible.com-1869306362.mp3',
                //     'Thwack Hit By Punch-SoundBible.com-872409685.mp3',
                //     'Roundhouse Kick-SoundBible.com-1663225804.mp3',
                //     'Spin Kick-SoundBible.com-1263586030.mp3',
                //     'Kick-SoundBible.com-1331196005.mp3',
                //     'Jab-SoundBible.com-1806727891.mp3',
                //     'Upper Cut-SoundBible.com-1272257235.mp3',
                //     'Right Cross-SoundBible.com-1721311663.mp3',
                //     'Left Hook-SoundBible.com-516660386.mp3',
                //     'Right Hook-SoundBible.com-1406389182.mp3'
                // ]
                // for (let i=0; i<my_sounds.length; i++) {
                //     this.sounds.push(new Sound(my_sounds[i]))
                // }
                ////// PLATFORMS ///////
                this.platforms = []
                this.ground = new Rectangle(0, this.height - this.ground_height,
                                            this.width, this.ground_height, 'green')
                this.platforms.push(this.ground)
                ////// STAR JUMPER!!! ///////
                let player_size = 20
                this.player = new StarJumper(sword_cnv.width/2-player_size/2,
                                            sword_cnv.height-this.ground_height-player_size*2,
                                            player_size, player_size*2, 'orange')
                ////// TARGET PRACTICE /////
                this.enemies = []
                this.enemy_shots = []
                for (let i=0; i<20; i++) {
                    let x = random(10, this.width-10)
                    let y = random(10, this.height-this.ground_height-player_size-10)
                    let enemy = new Rectangle(x, y, player_size, player_size, 'white')
                    this.enemies.push(enemy)
                }
                ////// GOLDEN STAR ///////
                this.point_star = new PointStar(random(100, this.width - 100),
                                                  random(0, this.height * .8),
                                                  this.star_size, this.star_size, 'deeppink')
                ////// PLATFORM STARS ///////
                for (let i=0; i<100; i++) {
                    let x = random(10, this.width-10)
                    let y = random(10, this.height-this.ground_height-this.star_size-10)
                    let star = new Rectangle(x, y, this.star_size, this.star_size, 'white')
                    this.platforms.push(star)
                }
                ////// PORTALS ///////
                this.portals = []
                let colors = ['red','orange', 'yellow', 'limegreen', 'mediumblue', 'darkorchid', 'white']
                for (let i=0; i<colors.length; i++) {
                    let x, y
                    let radius = 10 + Math.random() * 10;
                    let color = `hsl(${i*60}, 100%, 50%)`

                    x = random(radius, this.width - radius)
                    y = random(radius, this.height * .8)
                    let p1 = new Portal(x, y, radius, colors[i], Math.random()-.5, Math.random()-.5)

                    x = random(radius, this.width - radius)
                    y = random(radius, this.height * .8)
                    let p2 = new Portal(x, y, radius, colors[i], Math.random()-.5, Math.random()-.5)

                    this.portals.push(p1)
                    this.portals[this.portals.length - 1].portal_pair = p2
                    this.portals.push(p2)
                    this.portals[this.portals.length - 1].portal_pair = p1
                }
                ///// LEFT CLICK - SHOOT STAR ///////
                this.sword_cnv.onclick = (e) => {
                    if (this.player.flip_count <= 0 && this.player.energy >= 4) {
                        let trans_x = this.getTransX()
                        let clicked_x = e.clientX - this.cnv_rect.left - trans_x
                        let clicked_y = e.clientY - this.cnv_rect.top
                        let shot_vel = getShotVelocities(
                            clicked_x, clicked_y,
                            this.player.x + this.player.width/2,
                            this.player.y + this.player.height/2,
                            this.player.shot_speed)
                        let shot
                        if (this.player.color === 'red') {
                            this.player.mx = 2
                            this.player.shot_speed = 6
                            let target = getClosestTarget(clicked_x, clicked_y, this.enemies)
                            shot = new RedShot(
                                this.player.x + this.player.width / 2, this.player.y + this.player.height / 2,
                                this.star_size, this.star_size, this.player.color, shot_vel.vx, shot_vel.vy,
                                this.player, this.player.shot_speed, target)
                        } else if (this.player.color === 'yellow') {
                            this.player.mx = 2.5
                            this.player.shot_speed = 7
                            shot = new YellowShot(
                                this.player.x + this.player.width / 2, this.player.y + this.player.height / 2,
                                this.star_size, this.star_size, this.player.color, shot_vel.vx, shot_vel.vy,
                                this.player, this.player.shot_speed)
                        } else if (this.player.color === 'orange') {
                            this.player.mx = 1.5
                            this.player.shot_speed = 5
                            shot = new StarShot(
                                this.player.x + this.player.width / 2, this.player.y + this.player.height / 2,
                                this.star_size, this.star_size, this.player.color, shot_vel.vx, shot_vel.vy,
                                this.player, this.player.shot_speed)
                            let click_dx = clicked_x - (this.player.x + this.player.width/2)
                            let click_dy = clicked_y - (this.player.y + this.player.height/2)
                            let angle_in_rad = Math.atan2(click_dy, click_dx)

                            let mini_vel1 = {
                                vx: Math.cos(angle_in_rad + 0.2),
                                vy: Math.sin(angle_in_rad + 0.2)}
                            let mini_vel2 = {
                                vx: Math.cos(angle_in_rad - 0.2),
                                vy: Math.sin(angle_in_rad - 0.2)}

                            let rand = random(.5, .6) * this.player.shot_speed
                            let mini_shot = new StarShot(
                                this.player.x + this.player.width / 2,this.player.y + this.player.height / 2,
                                this.star_size, this.star_size, this.player.color,
                                mini_vel1.vx * rand, mini_vel1.vy * rand, this.player, 0)
                            this.player.shots.push(mini_shot)

                            rand = random(.5, .6) * this.player.shot_speed
                            mini_shot = new StarShot(
                                this.player.x + this.player.width / 2, this.player.y + this.player.height / 2,
                                this.star_size, this.star_size, this.player.color,
                                mini_vel2.vx * rand, mini_vel2.vy * rand, this.player, 0)
                            this.player.shots.push(mini_shot)
                        } else if (this.player.color === 'mediumblue') {

                        } else {
                            this.player.mx = 2
                            this.player.shot_speed = 6
                            shot = new StarShot(
                                this.player.x + this.player.width / 2, this.player.y + this.player.height / 2,
                                this.star_size, this.star_size, this.player.color, shot_vel.vx, shot_vel.vy,
                                this.player, this.player.shot_speed)
                        }
                        this.player.shots.push(shot)
                        this.player.energy -= 6
                    }
                }
                ///// RIGHT CLICK - SWORD SWIPE ///////
                this.sword_cnv.oncontextmenu = (e) => {
                    if (this.player.flip_count <= 0 && !this.player.staa_ridin) {
                        let trans_x = this.getTransX()
                        let result = this.player.getFlipAttack(e.clientX - this.cnv_rect.left - trans_x - this.player.width,
                            e.clientY - this.cnv_rect.top)
                        if (result) {
                            // this.sounds[Math.floor(Math.random() * this.sounds.length)].play()
                            this.player.sword_trail.push([])
                            this.player.sword_tip.x = this.player.x + this.player.width / 2
                            this.player.sword_tip.y = this.player.y + this.player.height / 2
                        }
                    }
                    return false
                }
            }
            update() {
                let total_velocity = 0
                for (let i = 0; i < this.portals.length; i++) {
                    total_velocity += Math.abs(this.portals[i].vx) + Math.abs(this.portals[i].vy)
                    ///// MOVE PORTAL, SIZE ACCORDING TO PORTAL PAIR /////
                    let portal_pair_position = Math.abs(this.portals[i].portal_pair.x - this.point_star.x) / this.width
                    this.portals[i].update(portal_pair_position)
                    ///// BOUNCE PORTALS OFF SIDES & GROUND //////
                    if (this.portals[i].x + this.portals[i].rad > this.width) {
                        this.portals[i].setRight(this.width)
                        this.portals[i].vx *= -1
                        this.portals[i].x += this.portals[i].vx
                    } else if (this.portals[i].x - this.portals[i].rad < 0) {
                        this.portals[i].setLeft(0)
                        this.portals[i].vx *= -1
                        this.portals[i].x += this.portals[i].vx
                    } else if (this.portals[i].y + this.portals[i].rad > this.height - this.ground_height) {
                        this.portals[i].setBottom(this.height - this.ground_height)
                        this.portals[i].vy *= -1
                        this.portals[i].y += this.portals[i].vy
                    } else if (this.portals[i].y - this.portals[i].rad < 0) {
                        this.portals[i].setTop(0)
                        this.portals[i].vy *= -1
                        this.portals[i].y += this.portals[i].vy
                    }
                    ///// CHECK TO SEE IF PORTAL HIT ANOTHER PORTAL //////
                    for (let j = i+1; j < this.portals.length; ++j) {
                        let result = this.portals[i].checkCollideCir(this.portals[j])
                        let dv = this.total_velocity < this.max_velocity ? this.dv : -this.dv*2
                        if (result && this.portals[i].vib_count <= 0) {
                            this.portals[i].vib_count = 60
                            this.portals[i].vy > 0 ? this.portals[i].vy += dv: this.portals[i].vy -= dv
                            this.portals[i].vx > 0 ? this.portals[i].vx += dv: this.portals[i].vx -= dv
                            this.portals[j].vib_count = 60
                            this.portals[j].vy > 0 ? this.portals[j].vy += dv: this.portals[j].vy -= dv
                            this.portals[j].vx > 0 ? this.portals[j].vx += dv: this.portals[j].vx -= dv
                        }
                    }
                    ///// SEE IF PORTAL HITS PLAYER, EXCEPT LAST PORTAL EXITED //////
                    if (this.portals[i] != this.player.last_teleport) {
                        let hit_player = this.portals[i].checkCollideRec(this.player)
                        if (hit_player) {
                            if (this.player.flip_count > 0) this.player.sword_trail.push([])
                            this.player.vy = 0
                            this.player.color = this.portals[i].color
                            this.player.last_teleport = this.portals[i].portal_pair
                            this.player.x = this.portals[i].portal_pair.x
                            this.player.y = this.portals[i].portal_pair.y
                        }
                    }
                    ///// SEE IF PORTAL HITS GOLDEN STAR, EXCEPT LAST PORTAL EXITED //////
                    if (this.portals[i] != this.point_star.last_teleport) {
                        let hit_point_star = this.portals[i].checkCollideRec(this.point_star)
                        if (hit_point_star) {
                            this.point_star.last_teleport = this.portals[i].portal_pair
                            this.point_star.x = this.portals[i].portal_pair.x
                            this.point_star.y = this.portals[i].portal_pair.y
                            if (this.portals[i].portal_pair.vx > 0) {
                                this.point_star.vx = -Math.abs(this.point_star.vx)
                            } else {
                                this.point_star.vx = Math.abs(this.point_star.vx)
                            }
                            if (this.portals[i].portal_pair.vy > 0) {
                                this.point_star.vy = -Math.abs(this.point_star.vy)
                            } else {
                                this.point_star.vy = Math.abs(this.point_star.vy)
                            }
                        }
                    }
                    ///// REDUCE VIBRATION COUNT //////
                    this.portals[i].vib_count -= 1
                }
                this.total_velocity = total_velocity
                ///// JUMP IF ON PLATFORM ////////
                if ((key_tracker.isKeyDown('ArrowUp') || key_tracker.isKeyDown('w')) && this.player_on_platform) {
                    this.player.vy = -6
                    this.player.y -= 0.3
                    this.player.staa_ridin = false
                }
                ///// DEFAULT ASSUMPTIONS, RESET, INCREMENT, ETC //////
                this.player_on_platform = false
                this.player.star_cooldown -= 1
                this.player.hurt_count -= 1
                let rubbing = false
                if (this.player.energy < 100) this.player.energy += .2
                ///// GO RIGHT OR LEFT /////
                if (!this.player.staa_ridin) {
                    if (key_tracker.isKeyDown('ArrowLeft')
                        || key_tracker.isKeyDown('a')
                        || key_tracker.isKeyDown(('A'))) {
                        if (this.player.flip_count <= 0) {
                            this.player.facing = -1 // left
                            ///// CHECK LEFT BUMP /////
                            for (let i = 0; i < this.platforms.length; i++) {
                                if (this.player.rubLeft(this.platforms[i])) {
                                    rubbing = true
                                    break
                                }
                            }
                        }
                        if (!rubbing) this.player.x -= this.player.mx
                        ///// TOO FAR LEFT /////
                        if (this.player.x < 0) this.player.x = 0
                    } else if (key_tracker.isKeyDown('ArrowRight')
                        || key_tracker.isKeyDown('d')
                        || key_tracker.isKeyDown('D')) {
                        if (this.player.flip_count <= 0) {
                            this.player.facing = 1 // right
                            ///// CHECK RIGHT BUMP /////
                            for (let i = 0; i < this.platforms.length; i++) {
                                if (this.player.rubRight(this.platforms[i])) {
                                    rubbing = true
                                    break
                                }
                            }
                        }
                        if (!rubbing) this.player.x += this.player.mx
                        ///// TOO FAR RIGHT /////
                        if (this.player.x + this.player.width > world.width) {
                            this.player.x = world.width - this.player.width
                        }
                    }
                }
                ///// CHECK IF NORMAL STARS ARE INSIDE SWORD TRAIL /////
                let trans_x = this.getTransX()
                for (let i=1; i<this.platforms.length; i++) {
                    if (this.platforms[i].x + trans_x < this.world_cnv.width && this.platforms[i].x + trans_x > 0) {
                        let sword_hit = checkAttackOnCTX(this.platforms[i].x + trans_x, this.platforms[i].y,
                            this.star_size, this.star_size, this.sword_ctx)
                        if (sword_hit) {
                            this.platforms.splice(i, 1)
                            this.player.star_count += 1
                        }
                    }
                }
                let take_shots = Math.random()<.005
                ///// CHECK CONTACT WITH ENEMIES /////
                for (let i=0; i<this.enemies.length; i++) {
                    let sword_hit = checkAttackOnCTX(this.enemies[i].x + trans_x, this.enemies[i].y,
                        this.enemies[i].width, this.enemies[i].height, this.sword_ctx)
                    if (sword_hit) {
                        this.enemies.splice(i, 1)
                    } else {
                        for (let j=0; j<this.player.shots.length; j++) {
                            if (this.player.shots[j].checkCollideRec(this.enemies[i])) {
                                this.enemies.splice(i, 1)
                                this.player.shots.splice(j, 1)
                                break
                            }
                        }
                    }
                    if (take_shots) {
                        let rand_vx = (Math.random()-.5)*2
                        let rand_vy = (Math.random()-.5)*2
                        if (rand_vx < 1) rand_vx *= 3
                        if (rand_vy < 1) rand_vy *= 3
                        this.enemy_shots.push(new StarShot(
                            this.enemies[i].x + this.enemies[i].width/2, this.enemies[i].y + this.enemies[i].height/2,
                            this.star_size, this.star_size, 'white', rand_vx, rand_vy, this.enemies[i]))
                    }
                }
                ///// CHECK SWORD CONTACT WITH ENEMY SHOTS /////
                for (let i=0; i<this.enemy_shots.length; i++) {
                    this.enemy_shots[i].update()
                    if (this.enemy_shots[i].x < 0 || this.enemy_shots[i].x > this.width ||
                        this.enemy_shots[i].y < 0 || this.enemy_shots[i].y > this.height) {
                            this.enemy_shots.splice(i, 1)
                        continue
                    }
                    let sword_hit = checkAttackOnCTX(this.enemy_shots[i].x + trans_x, this.enemy_shots[i].y,
                        this.star_size, this.star_size, this.sword_ctx)
                    if (sword_hit) {
                        this.player.shots.push(new StarShot(
                            this.enemy_shots[i].x, this.enemy_shots[i].y,
                            this.star_size, this.star_size, this.player.color,
                            -this.enemy_shots[i].vx * 2, -this.enemy_shots[i].vy * 2))
                        this.enemy_shots.splice(i, 1)
                    }
                }
                ///// BOUNCE GOLDEN STAR //////
                let is_ob_right = this.point_star.x + this.point_star.width > this.width
                let is_ob_left = this.point_star.x < 0
                if (is_ob_right || is_ob_left) this.point_star.vx *= -1
                let is_ob_top = this.point_star.y > this.height - this.ground.height - this.star_size
                let is_ob_bottom = this.point_star.y < 0
                if (is_ob_top || is_ob_bottom) this.point_star.vy *= -1
                ///// IF RIDING ON GOLDEN STAR /////
                this.point_star.update()
                if (this.player.staa_ridin) {
                    this.player_on_platform = true
                    this.player.x = this.point_star.x - (this.player.width - this.star_size) / 2
                    this.player.y = this.point_star.y - this.player.height
                    ///// PICK UP GOLDEN STAR  /////
                    if (key_tracker.isKeyDown('ArrowDown') || key_tracker.isKeyDown('s')) {
                        this.player.staa_ridin = false
                        this.player_on_platform = false
                        this.player.star_cooldown = 10
                        this.player.score += 1
                        this.point_star.x = random(0, this.width - this.star_size)
                        this.point_star.y = random(0, this.height - this.star_size - this.ground_height)
                        this.point_star.setRandomVelocities()
                    }
                ///// IF YOU LAND ON THE GOLDEN STAR /////
                } else if (this.player.landed(this.point_star) && !this.player.staa_ridin) {
                    this.player_on_platform = true
                    this.player.staa_ridin = true
                    this.player.flip_count = 0
                ///// IF YOU ARE FLIPPING, UP OR DOWN /////
                } else if (this.player.flip_count > 0) {
                    if (this.player.flip_type === 'up') {
                        this.player.vy -= .03
                    } else {
                        this.player.vy += .5
                    }
                    this.player.y += this.player.vy
                    if (this.player.y + this.player.height + this.ground.height >= this.height) {
                        this.player.y = this.height - this.player.height - this.ground.height
                        this.player.flip_count = 0
                    } else {
                        this.player.flip_count -= 1
                    }
                ///// OTHERWISE CHECK NORMAL HITS /////
                } else {
                    for (let i=0; i<this.platforms.length; i++) {
                        ///// LANDED ON STAR OR GROUND /////
                        if (this.player.landed(this.platforms[i])) {
                            this.player.y = this.platforms[i].top() - this.player.height
                            this.player.vy = 0
                            this.player_on_platform = true
                            ///// DOWN KEY = PICK UP STAR /////
                            if ((key_tracker.isKeyDown('ArrowDown') || key_tracker.isKeyDown('s'))
                                && this.platforms[i] != this.ground && this.player.star_cooldown < 0) {
                                    this.player.star_cooldown = 10
                                    this.player.grabStar()
                                    this.platforms.splice(i, 1)
                            }
                            break
                        ///// CHECK HEAD BUMP /////
                        } else if (this.player.hitHead(this.platforms[i]) && this.player.vy < 0
                            && this.platforms[i] != this.ground && this.player.flip_count <= 0) {
                                this.player.y = this.platforms[i].bottom() + .001
                                this.player.vy = -.015
                                break
                        }
                    }
                }
                ///// UPDATE STAR SHOTS /////
                for (let i=0; i<this.player.shots.length; i++) {
                    ///// UPDATE & BOUNCE SHOTS IN PLAY /////
                    if (this.player.shots[i].ground_timer === 0) {
                        ///// REMOVE EXPIRED STAR SHOTS
                        if (this.player.shots[i].life === 0) {
                            this.player.shots.splice(i, 1)
                        } else {
                            this.player.shots[i].update()
                            if (this.player.shots[i].life < 30) {
                                this.player.shots[i].width += 4 / this.player.shots[i].life
                                this.player.shots[i].height += 4 / this.player.shots[i].life
                                this.player.shots[i].x -= 2 / this.player.shots[i].life
                                this.player.shots[i].y -= 2 / this.player.shots[i].life
                            }
                            ///// SLOW AND BOUNCE STAR SHOTS IN PLAY /////
                            this.player.shots[i].life -= 1
                            this.player.shots[i].vx *= .994
                            this.player.shots[i].vy *= .994
                            this.player.shots[i].speed *= 0.994
                            if (this.player.shots[i].x > this.width - this.star_size) {
                                this.player.shots[i].vx *= -1
                                this.player.shots[i].x = this.width - this.star_size - this.player.shots[i].vx
                            } else if (this.player.shots[i].x < 0) {
                                this.player.shots[i].vx *= -1
                                this.player.shots[i].x = this.player.shots[i].vx
                            } else if (this.player.shots[i].y + this.star_size > this.height - this.ground_height) {
                                this.player.shots[i].y = this.height + this.star_size + this.ground_height
                                this.player.shots[i].ground_timer = 30
                            } else if (this.player.shots[i].y < 0) {
                                this.player.shots[i].vy *= -1
                                this.player.shots[i].y += this.player.shots[i].vy
                            }
                        }
                    ///// REMOVE INFLATED SHOTS THAT HAVE REACHED 1 /////
                    } else if (this.player.shots[i].ground_timer === 1) {
                        this.player.shots.splice(i, 1)
                    ///// INFLATE STARS THAT HAVE HIT GROUND /////
                    } else {
                        this.player.shots[i].ground_timer -= 1
                        this.player.shots[i].height += .6
                        this.player.shots[i].width += .6
                        this.player.shots[i].y = this.height - this.ground_height - this.player.shots[i].height
                        this.player.shots[i].x -= .3
                    }
                }
                ///// MID AIR SCENARIOS - NOT ON A PLATFORM OR GOLDEN STAR, NOT FLIPPING /////
                if (!this.player_on_platform && !this.player.staa_ridin && this.player.flip_count <= 0) {
                    this.player.vy += 0.2
                    this.player.y += this.player.vy
                    ///// CHECK GROUND BOUNCE /////
                    if (this.player.y + this.player.height + this.ground.height >= this.height) {
                        this.player.y = this.height - this.player.height - this.ground.height
                    }
                    ///// HIT DOWN KEY, S, OR SPACE TO ADD STAR UNDER STAR JUMPER /////
                    if ((key_tracker.isKeyDown(' ') || key_tracker.isKeyDown('s'))
                        && this.player.star_count > 0 && this.player.star_cooldown < 0) {
                            let new_star_x = this.player.x + (this.player.width - this.star_size) / 2
                            let new_star_y = this.player.y + this.player.height
                            let star = new Rectangle(new_star_x, new_star_y, this.star_size, this.star_size, 'white')
                            this.platforms.push(star)
                            this.player.vy = 0
                            this.player.star_cooldown = 10
                            this.player.star_count -= 1
                    }
                }
            }
            getTransX() {
                // trans_x is how far left to shift to get the right part of the world into view
                let trans_x = -this.player.x + this.world_cnv.width/2
                // if the adjustment would go past the end of the world...
                if (trans_x > 0) {
                    return  0
                } else if (trans_x < -this.width + this.world_cnv.width) {
                    return -this.width + this.world_cnv.width
                }
                return trans_x
            }
            draw() {
                this.world_ctx.clearRect(0, 0, this.world_cnv.width, this.world_cnv.height)
                this.sword_ctx.clearRect(0, 0, this.sword_cnv.width, this.sword_cnv.height)
                // this.player_shots_ctx.clearRect(0, 0, this.player_shots_cnv.width, this.player_shots_cnv.height)
                // this.enemy_attack_ctx.clearRect(0, 0, this.enemy_attack_cnv.width, this.enemy_attack_cnv.height)

                this.world_ctx.lineWidth = 3
                // this.sword_ctx.lineWidth = 3
                let trans_x = this.getTransX()
                this.world_cnv.style.backgroundPositionX = trans_x + 'px'
                this.sword_cnv.style.backgroundPositionX = trans_x + 'px'
                // this.player_shots_cnv.style.backgroundPositionX = trans_x + 'px'
                // this.enemy_attack_cnv.style.backgroundPositionX = trans_x + 'px'
                this.world_ctx.translate(trans_x, 0)
                this.sword_ctx.translate(trans_x, 0)
                // this.player_shots_ctx.translate(trans_x, 0)
                // this.enemy_attack_ctx.translate(trans_x, 0)

                for (let i=0; i<this.platforms.length; i++) {
                    this.platforms[i].draw(this.world_ctx)
                }
                for (let i=0; i<this.enemies.length; i++) {
                    this.enemies[i].draw(this.world_ctx)
                }
                for (let i=0; i<this.enemy_shots.length; i++) {
                    this.enemy_shots[i].draw(this.world_ctx)
                }
                for (let i=0; i<this.player.shots.length; i++) {
                    this.player.shots[i].draw(this.world_ctx)
                }

                for (let i=0; i<this.portals.length; i++) {
                    if (this.portals[i].vib_count > 0) {
                        if (this.portals[i].vib_count % 4 < 2) {
                            this.portals[i].rad += 2
                            this.portals[i].draw(this.world_ctx)
                            this.portals[i].rad -= 2
                        } else {
                            this.portals[i].draw(this.world_ctx)
                        }
                    } else {
                        this.portals[i].draw(this.world_ctx)
                    }
                }

                this.player.draw(this.world_ctx, this.sword_ctx)
                this.point_star.draw(this.world_ctx)
                this.world_ctx.resetTransform()
                this.sword_ctx.resetTransform()
                // this.player_shots_ctx.resetTransform()
                // this.enemy_attack_ctx.resetTransform()


                this.world_ctx.fillStyle = "white"
                this.world_ctx.font = "bolder 24px Arial"
                this.world_ctx.fillText('Star Pouch: ' + this.player.star_count, 8, 24)
                this.world_ctx.fillText('Score: ' + this.player.score, this.world_cnv.width - 100, 24)

                let status_bar_left = this.world_cnv.width * .25
                let status_bar_width = this.world_cnv.width * .5
                let player_position_in_world = (this.player.x + this.player.width / 2) / this.width
                let player_status_bar_position = status_bar_width * player_position_in_world + status_bar_left
                let point_star_position_in_world = (this.point_star.x + this.point_star.width / 2) / this.width
                let point_star_status_bar_position = status_bar_width * point_star_position_in_world + status_bar_left

                this.world_ctx.lineWidth = 2
                this.world_ctx.beginPath()
                this.world_ctx.moveTo(status_bar_left, 15)
                this.world_ctx.lineTo(status_bar_left + status_bar_width, 15)
                this.world_ctx.strokeStyle = 'white'
                this.world_ctx.stroke()

                this.world_ctx.lineWidth = 5
                this.world_ctx.beginPath()
                this.world_ctx.moveTo(player_status_bar_position, 7)
                this.world_ctx.lineTo(player_status_bar_position, 23)
                this.world_ctx.strokeStyle = this.player.color
                this.world_ctx.stroke()

                this.world_ctx.beginPath()
                this.world_ctx.moveTo(point_star_status_bar_position, 3)
                this.world_ctx.lineTo(point_star_status_bar_position, 27)
                this.world_ctx.strokeStyle = this.point_star.color
                this.world_ctx.stroke()

                this.world_ctx.lineWidth = 40
                this.world_ctx.beginPath()
                this.world_ctx.moveTo(30, 50)
                this.world_ctx.lineTo(30, 50 + this.player.base_energy - this.player.energy)
                this.world_ctx.strokeStyle = 'grey'
                this.world_ctx.stroke()

                this.world_ctx.beginPath()
                this.world_ctx.moveTo(30, 50 + this.player.base_energy)
                this.world_ctx.lineTo(30, 50 + this.player.base_energy - this.player.energy)
                this.world_ctx.strokeStyle = 'red'
                this.world_ctx.stroke()

                this.world_ctx.font = "14px Arial"
                this.world_ctx.fillText('energy', 9, 45)
                this.world_ctx.fillText('portal speeds: ' + Math.round(this.total_velocity*10)/10, 70, 45)
                this.world_ctx.fillText('time elapsed: ' +
                        Math.floor((this.current - this.start)/60000) + ":" +                       // MINUTES //
                        ("0" + Math.floor((this.current - this.start) / 1000) % 60).slice(-2),      // SECONDS //
                        70, 60)
                this.world_ctx.fillStyle = "black"
                this.world_ctx.font = "bolder 18px Arial"
                let t_left
                let t_energy = Math.round(this.player.energy)
                if (t_energy === 100) {
                    t_left = 15
                } else if (t_energy >= 10) {
                    t_left = 20
                } else {
                    t_left = 24
                }
                this.world_ctx.fillText(t_energy, t_left, 66)
            }
        }

        // function ShotBuilder () {
        //
        //     return shot
        // }

        class StarShot extends Rectangle {
            constructor(x, y, width, height, color, vx, vy, shooter, speed) {
                super(x, y, width, height, color)
                this.vx = vx
                this.vy = vy
                this.ground_timer = 0
                this.life = 60 * 6  // 6 seconds
                this.shooter = shooter
                this.o_speed = speed
                this.speed = speed
            }
        }

        class RedShot extends StarShot {
            constructor(x, y, width, height, color, vx, vy, shooter, speed, target) {
                super(x, y, width, height, color, vx, vy, shooter, speed)
                this.target = target
            }
            update() {
                let shot_velocities = getShotVelocities(
                    this.target.x + this.target.width/2,
                    this.target.y + this.target.height/2,
                    this.x + this.width/2,
                    this.y + this.height/2,
                    this.speed)
                this.vx = (this.vx * 74 + shot_velocities.vx) / 75
                this.vy = (this.vy * 74 + shot_velocities.vy) / 75
                this.x += this.vx
                this.y += this.vy
            }
        }

        class YellowShot extends StarShot {
            constructor(x, y, width, height, color, vx, vy, shooter, speed) {
                super(x, y, width, height, color, vx, vy, shooter, speed)
            }
            update() {
                if (this.life % 50 === 49) {
                    let d_vx = random(1, 2) * (Math.random() < 0.5 ? -1 : 1)
                    let d_vy = random(1, 2) * (Math.random() < 0.5 ? -1 : 1)
                    let denom = Math.abs(d_vx + this.vx) + Math.abs(d_vy + this.vy)
                    let n_vx = this.speed * (d_vx + this.vx) / denom
                    let n_vy = this.speed * (d_vy + this.vy) / denom
                    this.vx = n_vx
                    this.vy = n_vy
                }
                this.x += this.vx
                this.y += this.vy
            }
        }

        class BlueShot extends StarShot {
            constructor(x, y, width, height, color, vx, vy, shooter, speed) {
                super(x, y, width, height, color, vx, vy, shooter, speed)
                this.life = 10
            }

            update() {
                if (this.life === 0) {
                    return false
                } else {
                    this.x += this.vx
                    this.y += this.vy
                    this.life -= 1
                }
            }
        }

        class Portal {
            constructor(x, y, radius, color, vx=0, vy=0) {
                this.x = x
                this.y = y
                this.vx = vx
                this.vy = vy
                this.rad = radius
                this.color = color
                this.vib_count = 0
            }
            draw(world_ctx) {
                let grd = world_ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, this.rad);
                grd.addColorStop(0, 'transparent');
                grd.addColorStop(1, this.color);
                world_ctx.beginPath()
                world_ctx.arc(this.x, this.y, this.rad, 0, 2 * Math.PI, false)
                world_ctx.fillStyle = grd;
                world_ctx.fill();
            }
            update(rad_multi) {
                this.rad = 10 + rad_multi * 20
                this.x += this.vx
                this.y += this.vy
            }
            checkCollideRec(rec) {
                let dx = this.x - (rec.x + rec.width / 2)
                let dy = this.y - (rec.y + rec.height / 2)
                let x_width = (this.rad*2 + rec.width) / 2
                let x_height = (this.rad*2 + rec.height) / 2
                return Math.abs(dx) <= x_width && Math.abs(dy) <= x_height
            }
            checkCollideCir(cir) {
                let change_in_x = this.x - cir.x
                let change_in_y = this.y - cir.y
                let separation2 = change_in_x*change_in_x + change_in_y * change_in_y
                let combo_len = this.rad + cir.rad
                let combo_len2 = combo_len * combo_len
                if (separation2 <= combo_len2) {
                    let separation = Math.sqrt(separation2)
                    // YOUR BALLS ARE TOUCHING, SEPARATE THEM
                    let diff = combo_len - separation
                    let nudge = diff / 2
                    let x_part_of_separation = (change_in_x / separation) ** 2
                    let y_part_of_separation = (change_in_y / separation) ** 2
                    let nudge_x = nudge * x_part_of_separation
                    let nudge_y = nudge * y_part_of_separation
                    // NUDGE YOUR BALLS BACK TO TOUCHING EDGES
                    this.x -= nudge_x
                    this.y -= nudge_y
                    cir.x += nudge_x
                    cir.y += nudge_y
                    // CALCULATE NEW VELOCITIES
                    let collision_angle = Math.atan2(cir.y - this.y, cir.x - this.x)
                    let vel_vect_len_i = this.getVelVectLen()
                    let vel_vect_len_j = cir.getVelVectLen()
                    if (vel_vect_len_i + vel_vect_len_j > 0) {
                        let direction_i = Math.atan2(this.vy, this.vx)
                        let direction_j = Math.atan2(cir.vy, cir.vx)
                        let vx_new_plane_i = vel_vect_len_i * Math.cos(direction_i - collision_angle)
                        let vy_new_plane_i = vel_vect_len_i * Math.sin(direction_i - collision_angle)
                        let vx_new_plane_j = vel_vect_len_j * Math.cos(direction_j - collision_angle)
                        let vy_new_plane_j = vel_vect_len_j * Math.sin(direction_j - collision_angle)
                        let vx_final_i = ((this.rad - cir.rad) * vx_new_plane_i + (cir.rad + cir.rad) * vx_new_plane_j) / (this.rad + cir.rad)
                        let vx_final_j = ((this.rad + this.rad) * vx_new_plane_i + (cir.rad - this.rad) * vx_new_plane_j) / (this.rad + cir.rad)
                        let vy_final_i = vy_new_plane_i
                        let vy_final_j = vy_new_plane_j
                        let cosAngle = Math.cos(collision_angle)
                        let sinAngle = Math.sin(collision_angle)
                        this.vx = cosAngle * vx_final_i - sinAngle * vy_final_i
                        this.vy = sinAngle * vx_final_i + cosAngle * vy_final_i
                        cir.vx = cosAngle * vx_final_j - sinAngle * vy_final_j
                        cir.vy = sinAngle * vx_final_j + cosAngle * vy_final_j
                        // MOVE IN NEW DIRECTION ONE TICK
                        this.x += this.vx
                        this.y += this.vy
                        cir.x += cir.vx
                        cir.y += cir.vy
                    }
                    return true
                }
                return false
            }
            getVelVectLen() {
                return Math.sqrt(this.vx ** 2 + this.vy ** 2)
            }
            setLeft(x) {
                this.x = x + this.rad
            }
            setRight(x) {
                this.x = x - this.rad
            }
            setTop(y) {
                this.y = y + this.rad
            }
            setBottom(y) {
                this.y = y - this.rad
            }
        }

        class PointStar extends Rectangle {
            constructor(x, y, width, height, color) {
                super(x, y, width, height, color);
                this.setRandomVelocities()
                this.last_teleport = {}
            }
            setRandomVelocities() {
                let rand_vx = random(.5, 1) * (Math.random < .5 ? -1 : 1)
                let rand_vy = random(.5, 1) * (Math.random < .5 ? -1 : 1)
                this.vx = rand_vx
                this.vy = rand_vy
            }
        }

        // class Sound {
        //     constructor(src) {
        //         this.sound = document.createElement("audio");
        //         this.sound.src = src;
        //         this.sound.setAttribute("preload", "auto");
        //         this.sound.setAttribute("controls", "none");
        //         this.sound.style.display = "none";
        //         document.body.appendChild(this.sound);
        //     }
        //     play() {
        //         this.sound.play();
        //     }
        //     stop() {
        //         this.sound.pause();
        //     }
        // }


        let world = new World(world_cnv, sword_cnv)
        
        function animation_loop() {
            if (world.play) {
                window.requestAnimationFrame(animation_loop)
            }
            if (!world.start) world.start = Date.now()
            world.current = Date.now()
            world.update()
            world.draw()
        }
        window.requestAnimationFrame(animation_loop)
    </script>
</body>
</html>